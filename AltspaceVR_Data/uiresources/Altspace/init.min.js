if (!window.hasOwnProperty("altspace")) {
	Object.defineProperty(window, 'altspace', {
		configurable: false,
		enumerable: true,
		value: {},
		writable: false
	});

	altspace._internal = {};
	altspace._internal.Alt = window.Alt = {};
}

/* global jQuery, ActiveXObject, ArrayBuffer, DataView, Uint8Array */
(function (exports) {
'use strict';

var inherits = function(constructor, superConstructor, overrides) {
  function F() {}
  F.prototype = superConstructor.prototype;
  constructor.prototype = new F();
  if(overrides) {
    for(var prop in overrides)
      constructor.prototype[prop] = overrides[prop];
  }
};
/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var Thrift = {
    Version: '0.8.0',
/*
    Description: 'JavaScript bindings for the Apache Thrift RPC system',
    License: 'http://www.apache.org/licenses/LICENSE-2.0',
    Homepage: 'http://thrift.apache.org',
    BugReports: 'https://issues.apache.org/jira/browse/THRIFT',
    Maintainer: 'dev@thrift.apache.org',
*/

    Type: {
        'STOP' : 0,
        'VOID' : 1,
        'BOOL' : 2,
        'BYTE' : 3,
        'I08' : 3,
        'DOUBLE' : 4,
        'I16' : 6,
        'I32' : 8,
        'I64' : 10,
        'STRING' : 11,
        'UTF7' : 11,
        'STRUCT' : 12,
        'MAP' : 13,
        'SET' : 14,
        'LIST' : 15,
        'UTF8' : 16,
        'UTF16' : 17
    },

    MessageType: {
        'CALL' : 1,
        'REPLY' : 2,
        'EXCEPTION' : 3
    },

    objectLength: function(obj) {
        var length = 0;
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                length++;
            }
        }

        return length;
    },

    inherits: function(constructor, superConstructor) {
      //Prototypal Inheritance http://javascript.crockford.com/prototypal.html
      function F() {}
      F.prototype = superConstructor.prototype;
      constructor.prototype = new F();
    }
};



Thrift.TException = function(message) {
    this.message = message;
};
Thrift.inherits(Thrift.TException, Error);
Thrift.TException.prototype.name = 'TException';

Thrift.TApplicationExceptionType = {
    'UNKNOWN' : 0,
    'UNKNOWN_METHOD' : 1,
    'INVALID_MESSAGE_TYPE' : 2,
    'WRONG_METHOD_NAME' : 3,
    'BAD_SEQUENCE_ID' : 4,
    'MISSING_RESULT' : 5,
    'INTERNAL_ERROR' : 6,
    'PROTOCOL_ERROR' : 7
};

Thrift.TApplicationException = function(message, code) {
    this.message = message;
    this.code = (code === null) ? 0 : code;
};
Thrift.inherits(Thrift.TApplicationException, Thrift.TException);
Thrift.TApplicationException.prototype.name = 'TApplicationException';

Thrift.TApplicationException.prototype.read = function(input) {
    while (1) {
        var ret = input.readFieldBegin();

        if (ret.ftype == Thrift.Type.STOP) {
            break;
        }

        var fid = ret.fid;

        switch (fid) {
            case 1:
                if (ret.ftype == Thrift.Type.STRING) {
                    ret = input.readString();
                    this.message = ret.value;
                } else {
                    ret = input.skip(ret.ftype);
                }
                break;
            case 2:
                if (ret.ftype == Thrift.Type.I32) {
                    ret = input.readI32();
                    this.code = ret.value;
                } else {
                    ret = input.skip(ret.ftype);
                }
                break;
           default:
                ret = input.skip(ret.ftype);
                break;
        }

        input.readFieldEnd();
    }

    input.readStructEnd();
};

Thrift.TApplicationException.prototype.write = function(output) {
    var xfer = 0;

    output.writeStructBegin('TApplicationException');

    if (this.message) {
        output.writeFieldBegin('message', Thrift.Type.STRING, 1);
        output.writeString(this.getMessage());
        output.writeFieldEnd();
    }

    if (this.code) {
        output.writeFieldBegin('type', Thrift.Type.I32, 2);
        output.writeI32(this.code);
        output.writeFieldEnd();
    }

    output.writeFieldStop();
    output.writeStructEnd();
};

Thrift.TApplicationException.prototype.getCode = function() {
    return this.code;
};

Thrift.TApplicationException.prototype.getMessage = function() {
    return this.message;
};

/**
 *If you do not specify a url then you must handle ajax on your own.
 *This is how to use js bindings in a async fashion.
 */
Thrift.TXHRTransport = function(url) {
    this.url = url;
    this.wpos = 0;
    this.rpos = 0;

    this.send_buf = '';
    this.recv_buf = '';
};

Thrift.TXHRTransport.prototype = {

    //Gets the browser specific XmlHttpRequest Object
    getXmlHttpRequestObject: function() {
        try { return new XMLHttpRequest(); } catch (e1) { }
        try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch (e2) { }
        try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch (e3) { }

        throw "Your browser doesn't support the XmlHttpRequest object.";
    },

    flush: function(async) {
        //async mode
        if (async || this.url === undefined || this.url === '') {
            return this.send_buf;
        }

        var xreq = this.getXmlHttpRequestObject();

        if (xreq.overrideMimeType) {
            xreq.overrideMimeType('application/json');
        }

        xreq.open('POST', this.url, false);
        xreq.send(this.send_buf);

        if (xreq.readyState != 4) {
            throw 'encountered an unknown ajax ready state: ' + xreq.readyState;
        }

        if (xreq.status != 200) {
            throw 'encountered a unknown request status: ' + xreq.status;
        }

        this.recv_buf = xreq.responseText;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
    },

    jqRequest: function(client, postData, args, recv_method) {
        if (typeof jQuery === 'undefined' ||
            typeof jQuery.Deferred === 'undefined') {
            throw 'Thrift.js requires jQuery 1.5+ to use asynchronous requests';
        }

        // Deferreds
        var deferred = jQuery.Deferred();
        var completeDfd = jQuery._Deferred();
        var dfd = deferred.promise();
        dfd.success = dfd.done;
        dfd.error = dfd.fail;
        dfd.complete = completeDfd.done;

        var jqXHR = jQuery.ajax({
            url: this.url,
            data: postData,
            type: 'POST',
            cache: false,
            dataType: 'text',
            context: this,
            success: this.jqResponse,
            error: function(xhr, status, e) {
                deferred.rejectWith(client, jQuery.merge([e], xhr.tArgs));
            },
            complete: function(xhr, status) {
                completeDfd.resolveWith(client, [xhr, status]);
            }
        });

        deferred.done(jQuery.makeArray(args).pop()); //pop callback from args
        jqXHR.tArgs = args;
        jqXHR.tClient = client;
        jqXHR.tRecvFn = recv_method;
        jqXHR.tDfd = deferred;
        return dfd;
    },

    jqResponse: function(responseData, textStatus, jqXHR) {
      this.setRecvBuffer(responseData);
      try {
          var value = jqXHR.tRecvFn.call(jqXHR.tClient);
          jqXHR.tDfd.resolveWith(jqXHR, jQuery.merge([value], jqXHR.tArgs));
      } catch (ex) {
          jqXHR.tDfd.rejectWith(jqXHR, jQuery.merge([ex], jqXHR.tArgs));
      }
    },

    setRecvBuffer: function(buf) {
        this.recv_buf = buf;
        this.recv_buf_sz = this.recv_buf.length;
        this.wpos = this.recv_buf.length;
        this.rpos = 0;
    },

    isOpen: function() {
        return true;
    },

    open: function() {},

    close: function() {},

    read: function(len) {
        var avail = this.wpos - this.rpos;

        if (avail === 0) {
            return '';
        }

        var give = len;

        if (avail < len) {
            give = avail;
        }

        var ret = this.read_buf.substr(this.rpos, give);
        this.rpos += give;

        //clear buf when complete?
        return ret;
    },

    readAll: function() {
        return this.recv_buf;
    },

    write: function(buf) {
        this.send_buf = buf;
    },

    getSendBuffer: function() {
        return this.send_buf;
    }

};

Thrift.TStringTransport = function(recv_buf, callback) {
    this.send_buf = '';
    this.recv_buf = recv_buf || '';
    this.onFlush = callback;
};

Thrift.TStringTransport.prototype = {

    flush: function() {
      if(this.onFlush)
        this.onFlush(this.send_buf);
    },

    isOpen: function() {
        return true;
    },

    open: function() {},

    close: function() {},

    read: function(len) {
        return this.recv_buf;
    },

    readAll: function() {
        return this.recv_buf;
    },

    write: function(buf) {
        this.send_buf = buf;
    }

};

Thrift.Protocol = function(transport) {
    this.transport = transport;
};

Thrift.Protocol.Type = {};
Thrift.Protocol.Type[Thrift.Type.BOOL] = '"tf"';
Thrift.Protocol.Type[Thrift.Type.BYTE] = '"i8"';
Thrift.Protocol.Type[Thrift.Type.I16] = '"i16"';
Thrift.Protocol.Type[Thrift.Type.I32] = '"i32"';
Thrift.Protocol.Type[Thrift.Type.I64] = '"i64"';
Thrift.Protocol.Type[Thrift.Type.DOUBLE] = '"dbl"';
Thrift.Protocol.Type[Thrift.Type.STRUCT] = '"rec"';
Thrift.Protocol.Type[Thrift.Type.STRING] = '"str"';
Thrift.Protocol.Type[Thrift.Type.MAP] = '"map"';
Thrift.Protocol.Type[Thrift.Type.LIST] = '"lst"';
Thrift.Protocol.Type[Thrift.Type.SET] = '"set"';


Thrift.Protocol.RType = {};
Thrift.Protocol.RType.tf = Thrift.Type.BOOL;
Thrift.Protocol.RType.i8 = Thrift.Type.BYTE;
Thrift.Protocol.RType.i16 = Thrift.Type.I16;
Thrift.Protocol.RType.i32 = Thrift.Type.I32;
Thrift.Protocol.RType.i64 = Thrift.Type.I64;
Thrift.Protocol.RType.dbl = Thrift.Type.DOUBLE;
Thrift.Protocol.RType.rec = Thrift.Type.STRUCT;
Thrift.Protocol.RType.str = Thrift.Type.STRING;
Thrift.Protocol.RType.map = Thrift.Type.MAP;
Thrift.Protocol.RType.lst = Thrift.Type.LIST;
Thrift.Protocol.RType.set = Thrift.Type.SET;

Thrift.Protocol.Version = 1;

Thrift.Protocol.prototype = {

    getTransport: function() {
        return this.transport;
    },

    //Write functions
    writeMessageBegin: function(name, messageType, seqid) {
        this.tstack = [];
        this.tpos = [];

        this.tstack.push([Thrift.Protocol.Version, '"' +
            name + '"', messageType, seqid]);
    },

    writeMessageEnd: function() {
        var obj = this.tstack.pop();

        this.wobj = this.tstack.pop();
        this.wobj.push(obj);

        this.wbuf = '[' + this.wobj.join(',') + ']';

        this.transport.write(this.wbuf);
     },


    writeStructBegin: function(name) {
        this.tpos.push(this.tstack.length);
        this.tstack.push({});
    },

    writeStructEnd: function() {

        var p = this.tpos.pop();
        var struct = this.tstack[p];
        var str = '{';
        var first = true;
        for (var key in struct) {
            if (first) {
                first = false;
            } else {
                str += ',';
            }

            str += key + ':' + struct[key];
        }

        str += '}';
        this.tstack[p] = str;
    },

    writeFieldBegin: function(name, fieldType, fieldId) {
        this.tpos.push(this.tstack.length);
        this.tstack.push({ 'fieldId': '"' +
            fieldId + '"', 'fieldType': Thrift.Protocol.Type[fieldType]
        });

    },

    writeFieldEnd: function() {
        var value = this.tstack.pop();
        var fieldInfo = this.tstack.pop();

        this.tstack[this.tstack.length - 1][fieldInfo.fieldId] = '{' +
            fieldInfo.fieldType + ':' + value + '}';
        this.tpos.pop();
    },

    writeFieldStop: function() {
        //na
    },

    writeMapBegin: function(keyType, valType, size) {
        //size is invalid, we'll set it on end.
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[keyType],
            Thrift.Protocol.Type[valType], 0]);
    },

    writeMapEnd: function() {
        var p = this.tpos.pop();

        if (p == this.tstack.length) {
            return;
        }

        if ((this.tstack.length - p - 1) % 2 !== 0) {
            this.tstack.push('');
        }

        var size = (this.tstack.length - p - 1) / 2;

        this.tstack[p][this.tstack[p].length - 1] = size;

        var map = '}';
        var first = true;
        while (this.tstack.length > p + 1) {
            var v = this.tstack.pop();
            var k = this.tstack.pop();
            if (first) {
                first = false;
            } else {
                map = ',' + map;
            }

            if (! isNaN(k)) { k = '"' + k + '"'; } //json "keys" need to be strings
            map = k + ':' + v + map;
        }
        map = '{' + map;

        this.tstack[p].push(map);
        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    writeListBegin: function(elemType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[elemType], size]);
    },

    writeListEnd: function() {
        var p = this.tpos.pop();

        while (this.tstack.length > p + 1) {
            var tmpVal = this.tstack[p + 1];
            this.tstack.splice(p + 1, 1);
            this.tstack[p].push(tmpVal);
        }

        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    writeSetBegin: function(elemType, size) {
        this.tpos.push(this.tstack.length);
        this.tstack.push([Thrift.Protocol.Type[elemType], size]);
    },

    writeSetEnd: function() {
        var p = this.tpos.pop();

        while (this.tstack.length > p + 1) {
            var tmpVal = this.tstack[p + 1];
            this.tstack.splice(p + 1, 1);
            this.tstack[p].push(tmpVal);
        }

        this.tstack[p] = '[' + this.tstack[p].join(',') + ']';
    },

    writeBool: function(value) {
        this.tstack.push(value ? 1 : 0);
    },

    writeByte: function(i8) {
        this.tstack.push(i8);
    },

    writeI16: function(i16) {
        this.tstack.push(i16);
    },

    writeI32: function(i32) {
        this.tstack.push(i32);
    },

    writeI64: function(i64) {
        this.tstack.push(i64);
    },

    writeDouble: function(dbl) {
        this.tstack.push(dbl);
    },

    writeString: function(str) {
        // We do not encode uri components for wire transfer:
        if (str === null) {
            this.tstack.push(null);
        } else {
            // concat may be slower than building a byte buffer
            var escapedString = '';
            for (var i = 0; i < str.length; i++) {
                var ch = str.charAt(i);      // a single double quote: "
                if (ch === '\"') {
                    escapedString += '\\\"'; // write out as: \"
                } else if (ch === '\\') {    // a single backslash: \
                    escapedString += '\\\\'; // write out as: \\
                /* Currently escaped forward slashes break TJSONProtocol.
                 * As it stands, we can simply pass forward slashes into
                 * our strings across the wire without being escaped.
                 * I think this is the protocol's bug, not thrift.js
                 * } else if(ch === '/') {   // a single forward slash: /
                 *  escapedString += '\\/';  // write out as \/
                 * }
                 */
                } else if (ch === '\b') {    // a single backspace: invisible
                    escapedString += '\\b';  // write out as: \b"
                } else if (ch === '\f') {    // a single formfeed: invisible
                    escapedString += '\\f';  // write out as: \f"
                } else if (ch === '\n') {    // a single newline: invisible
                    escapedString += '\\n';  // write out as: \n"
                } else if (ch === '\r') {    // a single return: invisible
                    escapedString += '\\r';  // write out as: \r"
                } else if (ch === '\t') {    // a single tab: invisible
                    escapedString += '\\t';  // write out as: \t"
                } else {
                    escapedString += ch;     // Else it need not be escaped
                }
            }
            this.tstack.push('"' + escapedString + '"');
        }
    },

    writeBinary: function(str) {
        this.writeString(str);
    },



    // Reading functions
    readMessageBegin: function(name, messageType, seqid) {
        this.rstack = [];
        this.rpos = [];

        if (typeof jQuery !== 'undefined') {
            this.robj = jQuery.parseJSON(this.transport.readAll());
        } else {
            this.robj = eval(this.transport.readAll());
        }

        var r = {};
        var version = this.robj.shift();

        if (version != Thrift.Protocol.Version) {
            throw 'Wrong thrift protocol version: ' + version;
        }

        r.fname = this.robj.shift();
        r.mtype = this.robj.shift();
        r.rseqid = this.robj.shift();


        //get to the main obj
        this.rstack.push(this.robj.shift());

        return r;
    },

    readMessageEnd: function() {
    },

    readStructBegin: function(name) {
        var r = {};
        r.fname = '';

        //incase this is an array of structs
        if (this.rstack[this.rstack.length - 1] instanceof Array) {
            this.rstack.push(this.rstack[this.rstack.length - 1].shift());
        }

        return r;
    },

    readStructEnd: function() {
        if (this.rstack[this.rstack.length - 2] instanceof Array) {
            this.rstack.pop();
        }
    },

    readFieldBegin: function() {
        var r = {};

        var fid = -1;
        var ftype = Thrift.Type.STOP;

        //get a fieldId
        for (var f in (this.rstack[this.rstack.length - 1])) {
            if (f === null) {
              continue;
            }

            fid = parseInt(f, 10);
            this.rpos.push(this.rstack.length);

            var field = this.rstack[this.rstack.length - 1][fid];

            //remove so we don't see it again
            delete this.rstack[this.rstack.length - 1][fid];

            this.rstack.push(field);

            break;
        }

        if (fid != -1) {

            //should only be 1 of these but this is the only
            //way to match a key
            for (var i in (this.rstack[this.rstack.length - 1])) {
                if (Thrift.Protocol.RType[i] === null) {
                    continue;
                }

                ftype = Thrift.Protocol.RType[i];
                this.rstack[this.rstack.length - 1] =
                    this.rstack[this.rstack.length - 1][i];
            }
        }

        r.fname = '';
        r.ftype = ftype;
        r.fid = fid;

        return r;
    },

    readFieldEnd: function() {
        var pos = this.rpos.pop();

        //get back to the right place in the stack
        while (this.rstack.length > pos) {
            this.rstack.pop();
        }

    },

    readMapBegin: function(keyType, valType, size) {
        var map = this.rstack.pop();

        var r = {};
        r.ktype = Thrift.Protocol.RType[map.shift()];
        r.vtype = Thrift.Protocol.RType[map.shift()];
        r.size = map.shift();


        this.rpos.push(this.rstack.length);
        this.rstack.push(map.shift());

        return r;
    },

    readMapEnd: function() {
        this.readFieldEnd();
    },

    readListBegin: function(elemType, size) {
        var list = this.rstack[this.rstack.length - 1];

        var r = {};
        r.etype = Thrift.Protocol.RType[list.shift()];
        r.size = list.shift();

        this.rpos.push(this.rstack.length);
        this.rstack.push(list);

        return r;
    },

    readListEnd: function() {
        this.readFieldEnd();
    },

    readSetBegin: function(elemType, size) {
        return this.readListBegin(elemType, size);
    },

    readSetEnd: function() {
        return this.readListEnd();
    },

    readBool: function() {
        var r = this.readI32();

        if (r !== null && r.value == '1') {
            r.value = true;
        } else {
            r.value = false;
        }

        return r;
    },

    readByte: function() {
        return this.readI32();
    },

    readI16: function() {
        return this.readI32();
    },

    readI32: function(f) {
        if (f === undefined) {
            f = this.rstack[this.rstack.length - 1];
        }

        var r = {};

        if (f instanceof Array) {
            if (f.length === 0) {
                r.value = undefined;
            } else {
                r.value = f.shift();
            }
        } else if (f instanceof Object) {
           for (var i in f) {
                if (i === null) {
                  continue;
                }
                this.rstack.push(f[i]);
                delete f[i];

                r.value = i;
                break;
           }
        } else {
            r.value = f;
            this.rstack.pop();
        }

        return r;
    },

    readI64: function() {
        return this.readI32();
    },

    readDouble: function() {
        return this.readI32();
    },

    readString: function() {
        var r = this.readI32();
        return r;
    },

    readBinary: function() {
        return this.readString();
    },


    //Method to arbitrarily skip over data.
    skip: function(type) {
        throw 'skip not supported yet';
    }
};

Thrift.TJSONProtocol = function(transport) {
    this.transport = transport;
    this.reset();
};

Thrift.TJSONProtocol.Type = {};
Thrift.TJSONProtocol.Type[Thrift.Type.BOOL] = 'tf';
Thrift.TJSONProtocol.Type[Thrift.Type.BYTE] = 'i8';
Thrift.TJSONProtocol.Type[Thrift.Type.I16] = 'i16';
Thrift.TJSONProtocol.Type[Thrift.Type.I32] = 'i32';
Thrift.TJSONProtocol.Type[Thrift.Type.I64] = 'i64';
Thrift.TJSONProtocol.Type[Thrift.Type.DOUBLE] = 'dbl';
Thrift.TJSONProtocol.Type[Thrift.Type.STRUCT] = 'rec';
Thrift.TJSONProtocol.Type[Thrift.Type.STRING] = 'str';
Thrift.TJSONProtocol.Type[Thrift.Type.MAP] = 'map';
Thrift.TJSONProtocol.Type[Thrift.Type.LIST] = 'lst';
Thrift.TJSONProtocol.Type[Thrift.Type.SET] = 'set';

Thrift.TJSONProtocol.getValueFromScope = function(scope) {
  var listvalue = scope.listvalue;
  return listvalue ? listvalue.shift() : scope.value;
};

Thrift.TJSONProtocol.getScopeFromScope = function(scope) {
  var listvalue = scope.listvalue;
  if(listvalue)
    scope = {value:listvalue.shift()};
  return scope;
};

Thrift.TJSONProtocol.prototype = {

    reset: function() {
      this.elementStack = [];
    },

    //Write functions
    writeMessageBegin: function(name, messageType, seqid) {
      throw new Error("TJSONProtocol: Message not supported");
    },

    writeMessageEnd: function() {
    },

    writeStructBegin: function(name) {
      var container = {};
      this.elementStack.unshift(container);
    },

    writeStructEnd: function() {
      var container = this.elementStack.shift();
      if(this.elementStack.length == 0)
        this.transport.write(JSON.stringify(container));
      else
        this.elementStack[0].value.push(container);
    },

    writeFieldBegin: function(name, fieldType, fieldId) {
      var field = {name:name, fieldType:Thrift.TJSONProtocol.Type[fieldType], fieldId:fieldId, value:[]};
      this.elementStack.unshift(field);
    },

    writeFieldEnd: function() {
      var field = this.elementStack.shift();
      var fieldValue = {};
      fieldValue[field.fieldType] = field.value[0];
      this.elementStack[0][field.fieldId] = fieldValue;
    },

    writeFieldStop: function() {
        //na
    },

    writeMapBegin: function(keyType, valType, size) {
      var map = {value:[
        Thrift.TJSONProtocol.Type[keyType],
        Thrift.TJSONProtocol.Type[valType],
        size
      ]};
      this.elementStack.unshift(map);
    },

    writeMapEnd: function() {
      var map = this.elementStack.shift();
      this.elementStack[0].value.push(map.value);
    },

    writeListBegin: function(elemType, size) {
      var list = {name:name, value:[
        Thrift.TJSONProtocol.Type[elemType],
        size
      ]};
      this.elementStack.unshift(list);
    },

    writeListEnd: function() {
      var list = this.elementStack.shift();
      this.elementStack[0].value.push(list.value);
    },

    writeSetBegin: function(elemType, size) {
      var set = {name:name, value:[
        Thrift.TJSONProtocol.Type[elemType],
        size
      ]};
      this.elementStack.unshift(set);
    },

    writeSetEnd: function() {
      var set = this.elementStack.shift();
      this.elementStack[0].value.push(set.value);
    },

    writeBool: function(value) {
      this.elementStack[0].value.push(value ? 1 : 0);
    },

    writeByte: function(i8) {
      this.elementStack[0].value.push(i8);
    },

    writeI16: function(i16) {
      this.elementStack[0].value.push(i16);
    },

    writeI32: function(i32) {
      this.elementStack[0].value.push(i32);
    },

    writeI64: function(i64) {
      this.elementStack[0].value.push(i64);
    },

    writeDouble: function(dbl) {
      this.elementStack[0].value.push(dbl);
    },

    writeString: function(str) {
      this.elementStack[0].value.push(str);
    },

    writeBinary: function(str) {
      this.elementStack[0].value.push(str);
    },

    // Reading functions
    readMessageBegin: function(name, messageType, seqid) {
      throw new Error("TJSONProtocol: Message not supported");
    },

    readMessageEnd: function() {
    },

    readStructBegin: function(name) {
      var value;
      if(this.elementStack.length == 0)
        value = JSON.parse(this.transport.readAll());
      else
        value = Thrift.TJSONProtocol.getValueFromScope(this.elementStack[0]);

      var fields = [];
      for(var field in value)
        fields.push(field);
      this.elementStack.unshift({
        fields:fields,
        value:value
      });
      return {
        fname:''
      };
    },

    readStructEnd: function() {
      this.elementStack.shift();
    },

    readFieldBegin: function() {
      var scope = this.elementStack[0];
      var scopeValue = Thrift.TJSONProtocol.getValueFromScope(scope);
      var fid = scope.fields.shift();
      if(!fid)
        return {fname:'', ftype:Thrift.Type.STOP};

      var fieldValue = scopeValue[fid];
      for(var soleMember in fieldValue) {
        this.elementStack.unshift({value:fieldValue[soleMember]});
        return {
          fname:'',
          fid:Number(fid),
          ftype:Thrift.Protocol.RType[soleMember]
        };
      }
      /* there are no members, which is a format error */
      throw new Error("TJSONProtocol: parse error reading field value");
    },

    readFieldEnd: function() {
      this.elementStack.shift();
    },

    readMapBegin: function(keyType, valType, size) {
      var scope = this.elementStack[0];
      var value = Thrift.TJSONProtocol.getValueFromScope(scope);
      var result = {
        ktype:Thrift.Protocol.RType[value.shift()],
        vtype:Thrift.Protocol.RType[value.shift()],
        size:value.shift()
      };
      this.elementStack.unshift({listvalue:value});
      return result;
    },

    readMapEnd: function() {
      this.elementStack.shift();
    },

    readListBegin: function(elemType, size) {
      var scope = this.elementStack[0];
      var value = Thrift.TJSONProtocol.getValueFromScope(scope);
      var result = {
        etype:Thrift.Protocol.RType[value.shift()],
        size:value.shift()
      };
      this.elementStack.unshift({listvalue:value});
      return result;
    },

    readListEnd: function() {
      this.elementStack.shift();
    },

    readSetBegin: function(elemType, size) {
      var scope = this.elementStack[0];
      var value = Thrift.TJSONProtocol.getValueFromScope(scope);
      var result = {
        etype:Thrift.Protocol.RType[value.shift()],
        size:value.shift()
      };
      this.elementStack.unshift({listvalue:value});
      return result;
    },

    readSetEnd: function() {
      this.elementStack.shift();
    },

    readBool: function() {
      return !!Thrift.TJSONProtocol.getValueFromScope(this.elementStack[0]);
    },

    readByte: function() {
      return Thrift.TJSONProtocol.getValueFromScope(this.elementStack[0]);
    },

    readI16: function() {
      return Thrift.TJSONProtocol.getValueFromScope(this.elementStack[0]);
    },

    readI32: function(f) {
      return Thrift.TJSONProtocol.getValueFromScope(this.elementStack[0]);
    },

    readI64: function() {
      return Thrift.TJSONProtocol.getValueFromScope(this.elementStack[0]);
    },

    readDouble: function() {
      return Thrift.TJSONProtocol.getValueFromScope(this.elementStack[0]);
    },

    readString: function() {
      return Thrift.TJSONProtocol.getValueFromScope(this.elementStack[0]);
    },

    readBinary: function() {
      return Thrift.TJSONProtocol.getValueFromScope(this.elementStack[0]);
    },

    flush: function() {
      this.transport.flush();
    }
};
var Utf8 = {
  encode: function(string, view, off) {
    var pos = off;
    for(var n = 0; n < string.length; n++) {
      var c = string.charCodeAt(n);
      if (c < 128) {
        view.setInt8(pos++, c);
      } else if((c > 127) && (c < 2048)) {
        view.setInt8(pos++, (c >> 6) | 192);
        view.setInt8(pos++, (c & 63) | 128);
      } else {
        view.setInt8(pos++, (c >> 12) | 224);
        view.setInt8(pos++, ((c >> 6) & 63) | 128);
        view.setInt8(pos++, (c & 63) | 128);
      }
    }
    return (pos - off);
  },
  decode : function(view, off, length) {
    var string = "";
    var i = off;
    length += off;
    var c, c1, c2, c3;
    c = c1 = c2 = 0;
    while ( i < length ) {
      c = view.getInt8(i++);
      if (c < 128) {
        string += String.fromCharCode(c);
      } else if((c > 191) && (c < 224)) {
        c2 = view.getInt8(i++);
        string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
      } else {
        c2 = view.getInt8(i++);
        c3 = view.getInt8(i++);
        string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
      }
    }
    return string;
  }
};

/* constructor simply creates a buffer of a specified length */
var Buffer = function(length) {
  this.offset = 0;
  this.length = length;
  if(length) {
    var buf = this.buf = new ArrayBuffer(length);
    this.view = new DataView(buf);
  }
};
Thrift.Buffer = Buffer;

Buffer.prototype = {
  getArray: function() {
    if(!this.array)
      this.array = new Uint8Array(this.buf, this.offset, this.length);
    return this.array;
  },
  slice: function(start, end) {
    start = start || 0;
    end = end || this.length;
    var result = new Buffer();
    var length = result.length = end - start;
    var offset = result.offset = this.offset + start;
    var buf = result.buf = this.buf;
    result.view = new DataView(buf, offset, length);
    return result;
  },
  getInt8: function(off) {
    return this.view.getInt8(off);
  },
  getInt16: function(off) {
    return this.view.getInt16(off, false);
  },
  getInt32: function(off) {
    return this.view.getInt32(off, false);
  },
  getInt64: function(off) {
    var hi = this.view.getInt32(off, false);
    var lo = this.view.getUint32(off + 4, false);
    return new Int64(hi, lo);
  },
  getFloat64: function(off) {
    return this.view.getFloat64(off, false);
  },
  getUtf8String: function(off, utflen) {
    return Utf8.decode(this.view, off, utflen);
  },
  setInt8: function(off, v) {
    this.view.setInt8(off, v);
  },
  setInt16: function(off, v) {
    this.view.setInt16(off, v, false);
  },
  setInt32: function(off, v) {
    this.view.setInt32(off, v, false);
  },
  setInt64: function(off, v) {
    this.getArray().set(v.buffer, off);
  },
  setFloat64: function(off, v) {
    this.view.setFloat64(off, v, false);
  },
  setBuffer: function(off, v) {
    this.getArray().set(v.getArray(), off);
  },
  setRawString: function(off, v) {
    var arr = this.getArray();

    for (var i = 0, len = v.length; i < len; i++) {
      arr[i + off] = v.charCodeAt(i);
    }
  },
  setUtf8String: function(off, v) {
    return Utf8.encode(v, this.view, off);
  },
  inspect: function() {
    var result = 'length: ' + this.length + '\n';
    var idx = 0;
    while(idx < this.length) {
      for(var i = 0; (idx < this.length) && (i < 32); i++)
        result += this.view.getInt8(idx++).toString(16) + ' ';
      result += '\n';
    }
    return result;
  }
};

var CheckedBuffer = Thrift.CheckedBuffer = function(length) {
  Buffer.call(this, length);
};
inherits(CheckedBuffer, Buffer, {
  grow: function(extra) {
    extra = extra || 0;
    var len = this.length + Math.max(extra, this.length*0.41);
    var src = this.getArray();
    this.buf = new ArrayBuffer(len);
    this.view = new DataView(this.buf);
    this.getArray().set(src);
    this.offset = 0;
    this.length = len;
  },
  checkAvailable: function(off, extra) {
    if(off + extra >= this.length)
      this.grow(extra);
  },
  setInt8: function(off, v) {
    this.checkAvailable(1);
    this.view.setInt8(off, v);
  },
  setInt16: function(off, v) {
    this.checkAvailable(2);
    this.view.setInt16(off, v, false);
  },
  setInt32: function(off, v) {
    this.checkAvailable(4);
    this.view.setInt32(off, v, false);
  },
  setInt64: function(off, v) {
    this.checkAvailable(8);
    this.getArray().set(v.buffer, off);
  },
  setFloat64: function(off, v) {
    this.checkAvailable(8);
    this.view.setFloat64(off, v, false);
  },
  setBuffer: function(off, v) {
    this.checkAvailable(v.length);
    this.getArray().set(v.getArray(), off);
  },
  setUtf8String: function(off, v) {
    while(true) {
      try {
        return Utf8.encode(v, this.view, off);
      } catch(e) {
        this.grow();
      }
    }
  }
});
var emptyBuf = new Buffer(0);

var InputBufferUnderrunError = function() {
};

var TTransport = Thrift.TTransport = function(buffer, callback) {
  this.buf = buffer || emptyBuf;
  this.onFlush = callback;
  this.reset();
};

TTransport.receiver = function(callback) {
  return function(data) {
    callback(new TTransport(data));
  };
};

TTransport.prototype = {
  commitPosition: function(){},
  rollbackPosition: function(){},

  reset: function() {
    this.pos = 0;
  },

  // TODO: Implement open/close support
  isOpen: function() {return true;},
  open: function() {},
  close: function() {},

  read: function(len) { // this function will be used for each frames.
    var end = this.pos + len;

    if (this.buf.length < end) {
      throw new Error('read(' + len + ') failed - not enough data');
    }

    var buf = this.buf.slice(this.pos, end);
    this.pos = end;
    return buf;
  },

  readByte: function() {
    return this.buf.getInt8(this.pos++);
  },

  readI16: function() {
    var i16 = this.buf.getInt16(this.pos);
    this.pos += 2;
    return i16;
  },

  readI32: function() {
    var i32 = this.buf.getInt32(this.pos);
    this.pos += 4;
    return i32;
  },

  readDouble: function() {
    var d = this.buf.getFloat64(this.pos);
    this.pos += 8;
    return d;
  },

  readString: function(len) {
    var str = this.buf.getUtf8String(this.pos, len);
    this.pos += len;
    return str;
  },

  readAll: function() {
    return this.buf;
  },

  writeByte: function(v) {
    this.buf.setInt8(this.pos++, v);
  },

  writeI16: function(v) {
    this.buf.setInt16(this.pos, v);
    this.pos += 2;
  },

  writeI32: function(v) {
    this.buf.setInt32(this.pos, v);
    this.pos += 4;
  },

  writeI64: function(v) {
    this.buf.setInt64(this.pos, v);
    this.pos += 8;
  },

  writeDouble: function(v) {
    this.buf.setFloat64(this.pos, v);
    this.pos += 8;
  },

  write: function(buf) {
    if (typeof(buf) === 'string') {
      this.pos += this.setUtf8String(this.pos, buf);
    } else {
      this.setBuffer(this.pos, buf);
      this.pos += buf.length;
    }
  },

  writeWithLength: function(buf) {
    var len;
    if (typeof(buf) === 'string') {
      len = this.buf.setUtf8String(this.pos + 4, buf);
    } else {
      this.buf.setBuffer(this.pos + 4, buf);
      len = buf.length;
    }
    this.buf.setInt32(this.pos, len);
    this.pos += len + 4;
  },

  flush: function(flushCallback) {
    flushCallback = flushCallback || this.onFlush;
    if(flushCallback) {
      var out = this.buf.slice(0, this.pos);
      flushCallback(out);
    }
  }
};

var TFramedTransport = Thrift.TFramedTransport = function(buffer, callback) {
  TTransport.call(this, buffer, callback);
};
Thrift.TFramedTransport = TFramedTransport;

TFramedTransport.receiver = function(callback) {
  var frameLeft = 0,
      framePos = 0,
      frame = null;
  var residual = null;

  return function(data) {
    // Prepend any residual data from our previous read
    if (residual) {
      var dat = new Buffer(data.length + residual.length);
      residual.copy(dat, 0, 0);
      data.copy(dat, residual.length, 0);
      residual = null;
    }

    // framed transport
    while (data.length) {
      if (frameLeft === 0) {
        // TODO assumes we have all 4 bytes
        if (data.length < 4) {
          console.log("Expecting > 4 bytes, found only " + data.length);
          residual = data;
          break;
          //throw Error("Expecting > 4 bytes, found only " + data.length);
        }
        frameLeft = binary.readI32(data, 0);
        frame = new Buffer(frameLeft);
        framePos = 0;
        data = data.slice(4, data.length);
      }

      if (data.length >= frameLeft) {
        data.copy(frame, framePos, 0, frameLeft);
        data = data.slice(frameLeft, data.length);

        frameLeft = 0;
        callback(new TFramedTransport(frame));
      } else if (data.length) {
        data.copy(frame, framePos, 0, data.length);
        frameLeft -= data.length;
        framePos += data.length;
        data = data.slice(data.length, data.length);
      }
    }
  };
};

inherits(TFramedTransport, TTransport, {
  flush: function() {
    var that = this;
    // TODO: optimize this better, allocate one buffer instead of both:
    var framedBuffer = function(out) {
      if(that.onFlush) {
        var msg = new Buffer(out.length + 4);
        binary.writeI32(msg, out.length);
        out.copy(msg, 4, 0, out.length);
        that.onFlush(msg);
      }
    };
    TTransport.prototype.flush.call(this, framedBuffer);
  }
});
/**
 * Support for handling 64-bit int numbers in Javascript (node.js)
 *
 * JS Numbers are IEEE-754 binary double-precision floats, which limits the
 * range of values that can be represented with integer precision to:
 *
 * 2^^53 <= N <= 2^53
 *
 * Int64 objects wrap a node Buffer that holds the 8-bytes of int64 data.  These
 * objects operate directly on the buffer which means that if they are created
 * using an existing buffer then setting the value will modify the Buffer, and
 * vice-versa.
 *
 * Internal Representation
 *
 * The internal buffer format is Big Endian.  I.e. the most-significant byte is
 * at buffer[0], the least-significant at buffer[7].  For the purposes of
 * converting to/from JS native numbers, the value is assumed to be a signed
 * integer stored in 2's complement form.
 *
 * For details about IEEE-754 see:
 * http://en.wikipedia.org/wiki/Double_precision_floating-point_format
 */

// Useful masks and values for bit twiddling
var MASK31 =  0x7fffffff, VAL31 = 0x80000000;
var MASK32 =  0xffffffff, VAL32 = 0x100000000;

// Map for converting hex octets to strings
var _HEX = [];
for (var j = 0; j < 256; j++) {
  _HEX[j] = (j > 0xF ? '' : '0') + j.toString(16);
}

//
// Int64
//

/**
 * Constructor accepts any of the following argument types:
 *
 * new Int64(buffer[, offset=0]) - Existing Array or Uint8Array with element offset
 * new Int64(string)             - Hex string (throws if n is outside int64 range)
 * new Int64(number)             - Number (throws if n is outside int64 range)
 * new Int64(hi, lo)             - Raw bits as two 32-bit values
 */
var Int64 = function(a1, a2) {
  if (a1 instanceof Array) {
    this.buffer = a1;
    this.offset = a2 || 0;
  } else {
    this.buffer = this.buffer || new Array(8);
    this.offset = 0;
    this.setValue.apply(this, arguments);
  }
};


// Max integer value that JS can accurately represent
Int64.MAX_INT = Math.pow(2, 53);

// Min integer value that JS can accurately represent
Int64.MIN_INT = -Math.pow(2, 53);

Int64.prototype = {
  /**
   * Do in-place 2's compliment.  See
   * http://en.wikipedia.org/wiki/Two's_complement
   */
  _2scomp: function() {
    var b = this.buffer, o = this.offset, carry = 1;
    for (var i = o + 7; i >= o; i--) {
      var v = (b[i] ^ 0xff) + carry;
      b[i] = v & 0xff;
      carry = v >> 8;
    }
  },

  /**
   * Set the value. Takes any of the following arguments:
   *
   * setValue(string) - A hexidecimal string
   * setValue(number) - Number (throws if n is outside int64 range)
   * setValue(hi, lo) - Raw bits as two 32-bit values
   */
  setValue: function(hi, lo) {
    var negate = false;
    if (arguments.length == 1) {
      if (typeof(hi) == 'number') {
        // Simplify bitfield retrieval by using abs() value.  We restore sign
        // later
        negate = hi < 0;
        hi = Math.abs(hi);
        lo = hi % VAL32;
        hi = hi / VAL32;
        if (hi > VAL32) throw new RangeError(hi  + ' is outside Int64 range');
        hi = hi | 0;
      } else if (typeof(hi) == 'string') {
        hi = (hi + '').replace(/^0x/, '');
        lo = hi.substr(-8);
        hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : '';
        hi = parseInt(hi, 16);
        lo = parseInt(lo, 16);
      } else {
        throw new Error(hi + ' must be a Number or String');
      }
    }

    // Technically we should throw if hi or lo is outside int32 range here, but
    // it's not worth the effort. Anything past the 32'nd bit is ignored.

    // Copy bytes to buffer
    var b = this.buffer, o = this.offset;
    for (var i = 7; i >= 0; i--) {
      b[o+i] = lo & 0xff;
      lo = i == 4 ? hi : lo >>> 8;
    }

    // Restore sign of passed argument
    if (negate) this._2scomp();
  },

  /**
   * Convert to a native JS number.
   *
   * WARNING: Do not expect this value to be accurate to integer precision for
   * large (positive or negative) numbers!
   *
   * @param allowImprecise If true, no check is performed to verify the
   * returned value is accurate to integer precision.  If false, imprecise
   * numbers (very large positive or negative numbers) will be forced to +/-
   * Infinity.
   */
  toNumber: function(allowImprecise) {
    var b = this.buffer, o = this.offset;

    // Running sum of octets, doing a 2's complement
    var negate = b[0] & 0x80, x = 0, carry = 1;
    for (var i = 7, m = 1; i >= 0; i--, m *= 256) {
      var v = b[o+i];

      // 2's complement for negative numbers
      if (negate) {
        v = (v ^ 0xff) + carry;
        carry = v >> 8;
        v = v & 0xff;
      }

      x += v * m;
    }

    // Return Infinity if we've lost integer precision
    if (!allowImprecise && x >= Int64.MAX_INT) {
      return negate ? -Infinity : Infinity;
    }

    return negate ? -x : x;
  },

  /**
   * Convert to a JS Number. Returns +/-Infinity for values that can't be
   * represented to integer precision.
   */
  valueOf: function() {
    return this.toNumber(false);
  },

  /**
   * Return string value
   *
   * @param radix Just like Number#toString()'s radix
   */
  toString: function(radix) {
    return this.valueOf().toString(radix || 10);
  },

  /**
   * Return a string showing the buffer octets, with MSB on the left.
   *
   * @param sep separator string. default is '' (empty string)
   */
  toOctetString: function(sep) {
    var out = new Array(8);
    var b = this.buffer, o = this.offset;
    for (var i = 0; i < 8; i++) {
      out[i] = _HEX[b[o+i]];
    }
    return out.join(sep || '');
  },

  /**
   * Pretty output in console.log
   */
  inspect: function() {
    return '[Int64 value:' + this + ' octets:' + this.toOctetString(' ') + ']';
  }
};/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var Type = Thrift.Type;

var UNKNOWN = 0,
    INVALID_DATA = 1,
    NEGATIVE_SIZE = 2,
    SIZE_LIMIT = 3,
    BAD_VERSION = 4;

var TProtocolException = function(type, message) {
  Error.call(this, message);
  this.name = 'TProtocolException';
  this.type = type;
};
inherits(TProtocolException, Error);

var TBinaryProtocol = Thrift.TBinaryProtocol = function(trans, strictRead, strictWrite) {
  this.trans = trans;
  this.strictRead = (strictRead !== undefined ? strictRead : false);
  this.strictWrite = (strictWrite !== undefined ? strictWrite : true);
};
Thrift.TBinaryProtocol = TBinaryProtocol;

TBinaryProtocol.prototype.flush = function() {
  return this.trans.flush();
};

// NastyHaxx. JavaScript forces hex constants to be
// positive, converting this into a long. If we hardcode the int value
// instead it'll stay in 32 bit-land.

var VERSION_MASK = -65536, // 0xffff0000
    VERSION_1 = -2147418112, // 0x80010000
    TYPE_MASK = 0x000000ff;

TBinaryProtocol.prototype.writeMessageBegin = function(name, type, seqid) {
    if (this.strictWrite) {
      this.writeI32(VERSION_1 | type);
      this.writeString(name);
      this.writeI32(seqid);
    } else {
      this.writeString(name);
      this.writeByte(type);
      this.writeI32(seqid);
    }
};

TBinaryProtocol.prototype.writeMessageEnd = function() {
};

TBinaryProtocol.prototype.writeStructBegin = function(name) {
};

TBinaryProtocol.prototype.writeStructEnd = function() {
};

TBinaryProtocol.prototype.writeFieldBegin = function(name, type, id) {
  this.writeByte(type);
  this.writeI16(id);
};

TBinaryProtocol.prototype.writeFieldEnd = function() {
};

TBinaryProtocol.prototype.writeFieldStop = function() {
  this.writeByte(Type.STOP);
};

TBinaryProtocol.prototype.writeMapBegin = function(ktype, vtype, size) {
  this.writeByte(ktype);
  this.writeByte(vtype);
  this.writeI32(size);
};

TBinaryProtocol.prototype.writeMapEnd = function() {
};

TBinaryProtocol.prototype.writeListBegin = function(etype, size) {
  this.writeByte(etype);
  this.writeI32(size);
};

TBinaryProtocol.prototype.writeListEnd = function() {
};

TBinaryProtocol.prototype.writeSetBegin = function(etype, size) {
  this.writeByte(etype);
  this.writeI32(size);
};

TBinaryProtocol.prototype.writeSetEnd = function() {
};

TBinaryProtocol.prototype.writeBool = function(bool) {
  this.writeByte(bool ? 1 : 0);
};

TBinaryProtocol.prototype.writeByte = function(i8) {
  this.trans.writeByte(i8);
};

TBinaryProtocol.prototype.writeI16 = function(i16) {
  this.trans.writeI16(i16);
};

TBinaryProtocol.prototype.writeI32 = function(i32) {
  this.trans.writeI32(i32);
};

TBinaryProtocol.prototype.writeI64 = function(i64) {
  if (i64.buffer) {
    this.trans.writeI64(i64);
  } else {
    this.trans.writeI64(new Int64(i64));
  }
};

TBinaryProtocol.prototype.writeDouble = function(dub) {
  this.trans.writeDouble(dub);
};

TBinaryProtocol.prototype.writeString = function(arg) {
  this.trans.writeWithLength(arg);
};

TBinaryProtocol.prototype.writeBinary = function(arg) {
  this.trans.writeWithLength(arg);
};

TBinaryProtocol.prototype.readMessageBegin = function() {
  var sz = this.readI32();
  var type, name, seqid;

  if (sz < 0) {
    var version = sz & VERSION_MASK;
    if (version != VERSION_1) {
      console.log("BAD: " + version);
      throw TProtocolException(BAD_VERSION, "Bad version in readMessageBegin: " + sz);
    }
    type = sz & TYPE_MASK;
    name = this.readString();
    seqid = this.readI32();
  } else {
    if (this.strictRead) {
      throw TProtocolException(BAD_VERSION, "No protocol version header");
    }
    name = this.trans.read(sz);
    type = this.readByte();
    seqid = this.readI32();
  }
  return {fname: name, mtype: type, rseqid: seqid};
};

TBinaryProtocol.prototype.readMessageEnd = function() {
};

TBinaryProtocol.prototype.readStructBegin = function() {
  return {fname: ''};
};

TBinaryProtocol.prototype.readStructEnd = function() {
};

TBinaryProtocol.prototype.readFieldBegin = function() {
  var type = this.readByte();
  if (type == Type.STOP) {
    return {fname: null, ftype: type, fid: 0};
  }
  var id = this.readI16();
  return {fname: null, ftype: type, fid: id};
};

TBinaryProtocol.prototype.readFieldEnd = function() {
};

TBinaryProtocol.prototype.readMapBegin = function() {
  var ktype = this.readByte();
  var vtype = this.readByte();
  var size = this.readI32();
  return {ktype: ktype, vtype: vtype, size: size};
};

TBinaryProtocol.prototype.readMapEnd = function() {
};

TBinaryProtocol.prototype.readListBegin = function() {
  var etype = this.readByte();
  var size = this.readI32();
  return {etype: etype, size: size};
};

TBinaryProtocol.prototype.readListEnd = function() {
};

TBinaryProtocol.prototype.readSetBegin = function() {
  var etype = this.readByte();
  var size = this.readI32();
  return {etype: etype, size: size};
};

TBinaryProtocol.prototype.readSetEnd = function() {
};

TBinaryProtocol.prototype.readBool = function() {
  var i8 = this.readByte();
  if (i8 == 0) {
    return false;
  }
  return true;
};

TBinaryProtocol.prototype.readByte = function() {
  return this.trans.readByte();
};

TBinaryProtocol.prototype.readI16 = function() {
  return this.trans.readI16();
};

TBinaryProtocol.prototype.readI32 = function() {
  return this.trans.readI32();
};

TBinaryProtocol.prototype.readI64 = function() {
  return this.trans.readI64();
};

TBinaryProtocol.prototype.readDouble = function() {
  return this.trans.readDouble();
};

TBinaryProtocol.prototype.readBinary = function() {
  var len = this.readI32();
  return this.trans.read(len);
};

TBinaryProtocol.prototype.readString = function() {
  var len = this.readI32();
  return this.trans.readString(len);
};

TBinaryProtocol.prototype.getTransport = function() {
  return this.trans;
};

TBinaryProtocol.prototype.skip = function(type) {
  // console.log("skip: " + type);
  var r, i;
  switch (type) {
    case Type.STOP:
      return;
    case Type.BOOL:
      this.readBool();
      break;
    case Type.BYTE:
      this.readByte();
      break;
    case Type.I16:
      this.readI16();
      break;
    case Type.I32:
      this.readI32();
      break;
    case Type.I64:
      this.readI64();
      break;
    case Type.DOUBLE:
      this.readDouble();
      break;
    case Type.STRING:
      this.readString();
      break;
    case Type.STRUCT:
      this.readStructBegin();
      while (true) {
        r = this.readFieldBegin();
        if (r.ftype === Type.STOP) {
          break;
        }
        this.skip(r.ftype);
        this.readFieldEnd();
      }
      this.readStructEnd();
      break;
    case Type.MAP:
      r = this.readMapBegin();
      for (i = 0; i < r.size; ++i) {
        this.skip(r.ktype);
        this.skip(r.vtype);
      }
      this.readMapEnd();
      break;
    case Type.SET:
      r = this.readSetBegin();
      for (i = 0; i < r.size; ++i) {
        this.skip(r.etype);
      }
      this.readSetEnd();
      break;
    case Type.LIST:
      r = this.readListBegin();
      for (i = 0; i < r.size; ++i) {
        this.skip(r.etype);
      }
      this.readListEnd();
      break;
    default:
      throw Error("Invalid type: " + type);
  }
};

exports.Thrift = Thrift;

}(window));

altspace._internal.DynamicThriftBuffer = (function () {
	var constr = function() {
		var buffer;
		var transport;
		var protocol;
		var length;
		var bufferByteArray;

		var switchToBufferOfLength = function(newLength) {
			buffer = new Thrift.Buffer(newLength);
			bufferByteArray = new Uint8Array(buffer.buf);
			transport = new Thrift.TFramedTransport(buffer);
			protocol = new Thrift.TBinaryProtocol(transport);
			length = newLength;
		};

		this.grow = function(newLength) {
			// This reaches inside of the buffer object, kind of hacky.
			var oldArray = buffer.getArray();

			length = Math.floor(newLength);

			switchToBufferOfLength(length);
			buffer.getArray().set(oldArray);
			buffer.offset = 0;
			buffer.length = length;
		};

		this.getBinaryString = function(thriftObject) {
			transport.reset();

			while (true) {
				try {
					thriftObject.write(protocol);
					break;
				} catch (e) {
					if (length < 1024 * 1024 * 64) {
						this.grow(length * 1.4);
						if (this.profile) {
							console.warn(
								'Resizing the serialization buffer. ' +
								'Set the initialSerializationBufferSize option when getting the renderer to avoid this.',
								length);
						}
					} else {
						throw e;
					}
				}
			}

			return constr.toBinaryString(bufferByteArray, transport.pos);
		};

		// Start off with 1024 byte length.
		switchToBufferOfLength(1024);
	};

	constr.toBinaryString = function (arr, len) {
		var chunkSize = 0xffff;
		var numChunks = Math.floor(len / chunkSize) + (len % chunkSize == 0 ? 0 : 1);
		var outputStr = new Array(numChunks);

		for (var i = 0, c = 0; c < len; i++, c = i * chunkSize) {
			var lastIndex = i == numChunks - 1 ? len : (i + 1) * chunkSize;
			outputStr[i] = String.fromCharCode.apply(null, arr.subarray(c, lastIndex));
		}

		return outputStr.join("");
	};

	return constr;
}());


altspace._internal.ScratchThriftBuffer = new altspace._internal.DynamicThriftBuffer();

/* jslint browser: true, nomen: true, plusplus: true */
/* global module, define, global */

/// @file coherent.js
/// @namespace engine

/// Coherent Browser JavaScript interface.
/// The `engine` module contains all functions for communication between the UI and the game / application.
(function (factory) {
	if (typeof module === 'object' && module.exports) {
		module.exports = factory(global, global.engine, false);
	}
	if (typeof define === 'function') {
		define(function () {
			return factory(window, window.engine, true);
		});
	} else {
		window.engine = factory(window, window.engine, true);
	}

	// altvr, fired so we can extend window.engine ourselves immediately
	document.dispatchEvent(new Event("WindowEngineCreated"));
})(function (global, engine, hasOnLoad) {
	'use strict';


	/**
	* Event emitter
	*
	* @class Emitter
	*/
	function Emitter() {
		this.events = {};
	}

	function Handler(code, context) {
		this.code = code;
		this.context = context;
	}

	Emitter.prototype._createClear = function (object, name, handler) {
		return function() {
			var handlers = object.events[name];
			if (handlers) {
				var index = handlers.indexOf(handler);
				if (index != -1) {
					handlers.splice(index, 1);
					if (handlers.length === 0) {
						delete object.events[name];
					}
				}
			}
		};
	};

	/// @file coherent.js

	/**
	* Add a handler for an event
	*
	* @method on
	* @param name the event name
	* @param callback function to be called when the event is triggered
	* @param context this binding for executing the handler, defaults to the Emitter
	* @return connection object
	*/
	Emitter.prototype.on = function (name, callback, context) {
		var handlers = this.events[name];

		if (handlers === undefined) {
			handlers = this.events[name] = [];
		}

		var handler = new Handler(callback, context || this);
		handlers.push(handler);
		return { clear: this._createClear(this, name, handler) };
	};

	/**
	* Remove a handler from an event
	*
	* @method off
	* @param name the event name
	* @param callback function to be called when the event is triggered
	* @param context this binding for executing the handler, defaults to the Emitter
	* @return connection object
	*/
	Emitter.prototype.off = function (name, handler, context) {
		var handlers = this.events[name];

		if (handlers !== undefined) {
			context = context || this;

			var index;
			var length = handlers.length;
			for (index = 0; index < length; ++index) {
				var reg = handlers[index];
				if (reg.code == handler && reg.context == context) {
					break;
				}
			}
			if (index < length) {
				handlers.splice(index, 1);
				if (handlers.length === 0) {
					delete this.events[name];
				}
			}
		}
	};

	/**
	* Remove a handler from an event
	*
	* @method off
	* @param name the event name
	* @param callback function to be called when the event is triggered
	* @param context this binding for executing the handler, defaults to the Emitter
	* @return connection object
	*/
	Emitter.prototype.trigger = function (name) {
		var handlers = this.events[name];

		if (handlers !== undefined) {
			var args = Array.prototype.slice.call(arguments, 1);

			handlers.forEach(function (handler) {
				handler.code.apply(handler.context, args);
			});
		}
	};

	Emitter.prototype.merge = function (emitter) {
		var lhs = this.events,
			rhs = emitter.events,
			push = Array.prototype.push,
			events;

		for (var e in rhs) {
			events = lhs[e] = lhs[e] || [];
			push.apply(events, rhs[e]);
		}
	};

	var pending = 'pending';
	var fulfilled = 'fulfilled';
	var broken = 'broken';

	function callAsync(code, context, argument) {
		var async = function () {
			code.call(context, argument);
		};
		setTimeout(async);
	}

	function Promise () {
		this.emitter = new Emitter();
		this.state = pending;
		this.result = null;
	}

	Promise.prototype.resolve = function (result) {
		this.state = fulfilled;
		this.result = result;

		this.emitter.trigger(fulfilled, result);
	};

	Promise.prototype.reject = function (result) {
		this.state = broken;
		this.result = result;

		this.emitter.trigger(broken, result);
	};

	Promise.prototype.success = function (code, context) {
		if (this.state !== fulfilled) {
			this.emitter.on(fulfilled, code, context);
		} else {
			callAsync(code, context || this, this.result);
		}
		return this;
	};

	Promise.prototype.always = function (code, context) {
		this.success(code, context);
		this.otherwise(code, context);
		return this;
	};

	Promise.prototype.otherwise = function (code, context) {
		if (this.state !== broken) {
			this.emitter.on(broken, code, context);
		} else {
			callAsync(code, context || this, this.result);
		}
		return this;
	};
	Promise.prototype.catch = Promise.prototype.otherwise;

	Promise.prototype.merge = function (other) {
		if (this.state === pending) {
			this.emitter.merge(other.emitter);
		} else {
			var handlers = other.emitter.events[this.state];
			var self = this;
			if (handlers !== undefined) {
				handlers.forEach(function (handler) {
					handler.code.call(handler.context, self.result);
				});
			}
		}
	};

	Promise.prototype.make_chain = function (handler, promise, ok) {
		return function (result) {
			var handlerResult;
			try {
				handlerResult = handler.code.call(handler.context, result);
				if (handlerResult instanceof Promise) {
					handlerResult.merge(promise);
				} else if (this.state === ok) {
					promise.resolve(handlerResult);
				} else {
					promise.reject(handlerResult);
				}
			} catch (error) {
				console.error('Error in promise.', error.stack);
				promise.reject(error);
			}
		};
	};

	function makeDefaultHandler(promise) {
		return function () {
			return promise;
		};
	}

	Promise.prototype.then = function (callback, errback) {
		var promise = new Promise();

		var handler = new Handler(callback || makeDefaultHandler(this), this);

		this.success(this.make_chain(handler, promise, fulfilled), this);

		var errorHandler = new Handler(errback || makeDefaultHandler(this), this);
		this.otherwise(this.make_chain(errorHandler, promise, broken), this);


		return promise;
	};

	var isAttached = engine !== undefined;

	engine = engine || {};

	engine.events = {};
	for (var property in Emitter.prototype) {
		engine[property] = Emitter.prototype[property];
	}

	/// @function engine.on
	/// Register handler for and event
	/// @param {String} name name of the event
	/// @param {Function} callback callback function to be executed when the event has been triggered
	/// @param context *this* context for the function, by default the engine object

	/// @function engine.off
	/// Remove handler for an event
	/// @param {String} name name of the event, by default removes all events
	/// @param {Function} callback the callback function to be removed, by default removes all callbacks for a given event
	/// @param context *this* context for the function, by default all removes all callbacks, regardless of context
	/// @warning Removing all handlers for `engine` will remove some *Coherent Browser* internal events, breaking some functionality.

	/// @function engine.trigger
	/// Trigger an event
	/// This function will trigger any C++ handler registered for this event with `Coherent::UI::View::RegisterForEvent`
	/// @param {String} name name of the event
	/// @param ... any extra arguments to be passed to the event handlers

	engine._trigger = Emitter.prototype.trigger;
	var concatArguments = Array.prototype.concat;
	engine.trigger = function (name) {
		this._trigger.apply(this, arguments);
		if (this._eventHandles[name] === undefined && this.IsAttached)
		{
			this.TriggerEvent.apply(this, arguments);
		}
		if (this.events.all !== undefined) {
			var allArguments = concatArguments.apply(['all'], arguments);
			this._trigger.apply(this, allArguments);
		}
	};

	engine.IsAttached = isAttached;
	engine._BindingsReady = false;
	engine._WindowLoaded = false;
	engine._RequestId = Math.floor(Math.random() * Math.pow(2, 15) - 1) << 16;//AltspaceVR, start each frame's RequestId at a random number so that they don't collide
	engine._ActiveRequests = {};

	// Begin AltspaceVR //
    // This enables the cascading of _Return events to lower iframes
	var iframes = document.getElementsByTagName('iframe');//This is a live NodeList
	function propagateToIFrames(event) {
	    if (!window.Alt || !window.Alt.shouldSupportIFrames) return;

	    for (var i = 0, max = iframes.length; i < max; i++) {
	        var iframe = iframes[i];
	        iframe.contentWindow.postMessage(event, '*');
	    }
	}
	window.addEventListener('message', function (event) {
	    if (event.data.isAltspaceIFrameResult) {
	        engine._Result.apply(engine, event.data.args);
	    }
	});
    // End AltspaceVR //

	if (!engine.IsAttached) {
		engine.SendMessage = function (name, id) {
			var args = Array.prototype.slice.call(arguments, 2);
			var deferred = engine._ActiveRequests[id];

			delete engine._ActiveRequests[id];

			args.push(deferred);

			var call = (function (name, args) {
				return function () {
					var mock = engine['Mock_' + name];

					if (mock !== undefined) {
						var callMock = function () {
							mock.apply(engine, args);
						};
						window.setTimeout(callMock, 16);
					}
				};
			}(name, args));

			window.setTimeout(call, 16);
		};

		engine.TriggerEvent = function () {
			var args = Array.prototype.slice.call(arguments),
				trigger;

			args[0] = 'Fake_' + args[0];

			trigger = (function (args) {
				return function () {
					engine.trigger.apply(engine, args);
				};
			}(args));

			window.setTimeout(trigger, 16);
		};

		engine.BindingsReady = function () {
			engine._OnReady();
		};

		engine.__observeLifetime = function () {
		};
	}

	/// @function engine.createDeferred
	/// Create a new deferred object.
	/// Use this to create deferred / promises that can be used together with `engine.call`.
	/// @return {Deferred} a new deferred object
	/// @see @ref CustomizingPromises
	engine.createDeferred = (global.engineCreateDeferred === undefined) ?
		function () { return new Promise(); }
		: global.engineCreateDeferred;

	/// @function engine.call
	/// Call asynchronously a C++ handler and retrieve the result
	/// The C++ handler must have been registered with `Coherent::UI::View::BindCall`
	/// @param {String} name name of the C++ handler to be called
	/// @param ... any extra parameters to be passed to the C++ handler
	/// @return {Deferred} deferred object whose promise is resolved with the result of the C++ handler
	engine.call = function () {
		engine._RequestId++;
		var id = engine._RequestId;

		var deferred = engine.createDeferred();
		engine._ActiveRequests[id] = deferred;
		var messageArguments = Array.prototype.slice.call(arguments);
		messageArguments.splice(1, 0, id);

		engine.SendMessage.apply(this, messageArguments);
		return deferred;
	};

	engine._Result = function (requestId) {
		var deferred = engine._ActiveRequests[requestId];
		if (deferred !== undefined)
		{
			delete engine._ActiveRequests[requestId];

			var resultArguments = Array.prototype.slice.call(arguments);
			resultArguments.shift();
			deferred.resolve.apply(deferred, resultArguments);
		} else // AltspaceVR, propagate any returned calls that we don't recognize to lower iframes (since they probabably made the call).
		{
		    propagateToIFrames({ isAltspaceIFrameResult: true, args: Array.prototype.slice.call(arguments) });
		}
	};

	engine._Errors = [ 'Success', 'ArgumentType', 'NoSuchMethod', 'NoResult' ];

	engine._ForEachError = function (errors, callback) {
		var length = errors.length;

		for (var i = 0; i < length; ++i) {
			callback(errors[i].first, errors[i].second);
		}
	};

	engine._MapErrors = function (errors) {
		var length = errors.length;

		for (var i = 0; i < length; ++i) {
			errors[i].first = engine._Errors[errors[i].first];
		}
	};

	engine._TriggerError = function (type, message) {
		engine.trigger('Error', type, message);
	};

	engine._OnError = function (requestId, errors) {
		engine._MapErrors(errors);

		if (requestId === null || requestId === 0) {
			engine._ForEachError(errors, engine._TriggerError);
		}
		else {
			var deferred = engine._ActiveRequests[requestId];

			delete engine._ActiveRequests[requestId];

			deferred.reject(errors);
		}
	};

	engine._eventHandles = {};

	engine._Register = function (eventName) {
		var trigger = (function (name, engine) {
			return function () {
				var eventArguments = [name];
				eventArguments.push.apply(eventArguments, arguments);
				engine.TriggerEvent.apply(this, eventArguments);
			};
		}(eventName, engine));

		engine._eventHandles[eventName] = engine.on(eventName, trigger);
	};

	engine._removeEventThunk = function (name) {
		var handle = engine._eventHandles[name];
		handle.clear();
		delete engine._eventHandles[name];
	};

	engine._Unregister = function (name) {
		if (typeof name === 'string') {
			engine._removeEventThunk(name);
		} else {
			name.forEach(engine._removeEventThunk, engine);
		}
	};

	function createMethodStub(name) {
		var stub = function() {
			var args = Array.prototype.slice.call(arguments);
			args.splice(0, 0, name, this._id);
			return engine.call.apply(engine, args);
		};
		return stub;
	}

	engine._boundTypes = {};

	engine._createInstance = function (args) {
		var type = args[0],
			id = args[1],
			methods = args[2],
			Constructor = engine._boundTypes[type];

		if (Constructor === undefined) {
			Constructor = function (id) {
				this._id = id;
			};
			Constructor.prototype.__Type = type;
			methods.forEach(function (name) {
				Constructor.prototype[name] = createMethodStub(type + '_' + name);
			});
			engine._boundTypes[type] = Constructor;
		}

		var instance = new Constructor(id);
		engine.__observeLifetime(instance);
		return instance;
	};

	engine._OnReady = function () {
		engine._BindingsReady = true;
		if (engine._WindowLoaded) {
			engine.trigger('Ready');
		}
	};

	engine._OnWindowLoaded = function () {
		engine._WindowLoaded = true;
		if (engine._BindingsReady) {
			engine.trigger('Ready');
		}
	};

	if (hasOnLoad) {
		global.onload = (function (originalWindowLoaded) {
			return function () {
				if (originalWindowLoaded) {
					originalWindowLoaded();
				}
				engine._OnWindowLoaded();
			};
		}(global.onload));
	} else {
		engine._WindowLoaded = true;
	}

	engine._coherentGlobalCanvas = document.createElement('canvas');
	engine._coherentGlobalCanvas.id     = "coherentGlobalCanvas";
	engine._coherentGlobalCanvas.width  = 1;
	engine._coherentGlobalCanvas.height = 1;
	engine._coherentGlobalCanvas.style.zIndex   = 0;
	engine._coherentGlobalCanvas.style.position = "absolute";
	engine._coherentGlobalCanvas.style.border   = "0px solid";

	engine._coherentLiveImageData = [];
	engine._coherentCreateImageData = function(name, guid) {
		var ctx = engine._coherentGlobalCanvas.getContext("2d");

		var coherentImage = ctx.coherentCreateImageData(guid);
		engine._coherentLiveImageData[name] = coherentImage;
	};
	engine._coherentUpdatedImageData = function(name) {
		engine._coherentLiveImageData[name].coherentUpdate();
		var canvases = document.getElementsByTagName('canvas');
		for(var i = 0; i < canvases.length; ++i) {
			if(!!canvases[i].onEngineImageDataUpdated) {
				canvases[i].onEngineImageDataUpdated(name,
					engine._coherentLiveImageData[name]);
			}
		}
	};

	engine.on("_coherentCreateImageData", engine._coherentCreateImageData);
	engine.on("_coherentUpdatedImageData", engine._coherentUpdatedImageData);

	engine.on('_Result', engine._Result, engine);
	engine.on('_Register', engine._Register, engine);
	engine.on('_Unregister', engine._Unregister, engine);
	engine.on('_OnReady', engine._OnReady, engine);
	engine.on('_OnError', engine._OnError, engine);

	engine.BindingsReady();

	return engine;
});


//     Underscore.js 1.6.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.6.0';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return obj;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
    return obj;
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var result;
    any(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);
    each(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, function(value, index, list) {
      return !predicate.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);
    each(obj, function(value, index, list) {
      if (!(result = result && predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);
    each(obj, function(value, index, list) {
      if (result || (result = predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    var result = -Infinity, lastComputed = -Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed > lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    var result = Infinity, lastComputed = Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed < lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return value;
    return _.property(value);
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, iterator, context) {
    iterator = lookupIterator(iterator);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iterator, context) {
      var result = {};
      iterator = lookupIterator(iterator);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    _.has(result, key) ? result[key].push(value) : result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Split an array into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(array, predicate) {
    var pass = [], fail = [];
    each(array, function(elem) {
      (predicate(elem) ? pass : fail).push(elem);
    });
    return [pass, fail];
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.contains(other, item);
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    return function() {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _) args[i] = arguments[position++];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error('bindAll must be passed function names');
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;
      if (last < wait) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  _.constant = function(value) {
    return function () {
      return value;
    };
  };

  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
  _.matches = function(attrs) {
    return function(obj) {
      if (obj === attrs) return true; //avoid comparing an object to itself.
      for (var key in attrs) {
        if (attrs[key] !== obj[key])
          return false;
      }
      return true;
    }
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() { return new Date().getTime(); };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}).call(this);

(function(t,e){if(typeof define==="function"&&define.amd){define(["underscore","jquery","exports"],function(i,r,s){t.Backbone=e(t,s,i,r)})}else if(typeof exports!=="undefined"){var i=require("underscore");e(t,exports,i)}else{t.Backbone=e(t,{},t._,t.jQuery||t.Zepto||t.ender||t.$)}})(this,function(t,e,i,r){var s=t.Backbone;var n=[];var a=n.push;var o=n.slice;var h=n.splice;e.VERSION="1.1.2";e.$=r;e.noConflict=function(){t.Backbone=s;return this};e.emulateHTTP=false;e.emulateJSON=false;var u=e.Events={on:function(t,e,i){if(!c(this,"on",t,[e,i])||!e)return this;this._events||(this._events={});var r=this._events[t]||(this._events[t]=[]);r.push({callback:e,context:i,ctx:i||this});return this},once:function(t,e,r){if(!c(this,"once",t,[e,r])||!e)return this;var s=this;var n=i.once(function(){s.off(t,n);e.apply(this,arguments)});n._callback=e;return this.on(t,n,r)},off:function(t,e,r){var s,n,a,o,h,u,l,f;if(!this._events||!c(this,"off",t,[e,r]))return this;if(!t&&!e&&!r){this._events=void 0;return this}o=t?[t]:i.keys(this._events);for(h=0,u=o.length;h<u;h++){t=o[h];if(a=this._events[t]){this._events[t]=s=[];if(e||r){for(l=0,f=a.length;l<f;l++){n=a[l];if(e&&e!==n.callback&&e!==n.callback._callback||r&&r!==n.context){s.push(n)}}}if(!s.length)delete this._events[t]}}return this},trigger:function(t){if(!this._events)return this;var e=o.call(arguments,1);if(!c(this,"trigger",t,e))return this;var i=this._events[t];var r=this._events.all;if(i)f(i,e);if(r)f(r,arguments);return this},stopListening:function(t,e,r){var s=this._listeningTo;if(!s)return this;var n=!e&&!r;if(!r&&typeof e==="object")r=this;if(t)(s={})[t._listenId]=t;for(var a in s){t=s[a];t.off(e,r,this);if(n||i.isEmpty(t._events))delete this._listeningTo[a]}return this}};var l=/\s+/;var c=function(t,e,i,r){if(!i)return true;if(typeof i==="object"){for(var s in i){t[e].apply(t,[s,i[s]].concat(r))}return false}if(l.test(i)){var n=i.split(l);for(var a=0,o=n.length;a<o;a++){t[e].apply(t,[n[a]].concat(r))}return false}return true};var f=function(t,e){var i,r=-1,s=t.length,n=e[0],a=e[1],o=e[2];switch(e.length){case 0:while(++r<s)(i=t[r]).callback.call(i.ctx);return;case 1:while(++r<s)(i=t[r]).callback.call(i.ctx,n);return;case 2:while(++r<s)(i=t[r]).callback.call(i.ctx,n,a);return;case 3:while(++r<s)(i=t[r]).callback.call(i.ctx,n,a,o);return;default:while(++r<s)(i=t[r]).callback.apply(i.ctx,e);return}};var d={listenTo:"on",listenToOnce:"once"};i.each(d,function(t,e){u[e]=function(e,r,s){var n=this._listeningTo||(this._listeningTo={});var a=e._listenId||(e._listenId=i.uniqueId("l"));n[a]=e;if(!s&&typeof r==="object")s=this;e[t](r,s,this);return this}});u.bind=u.on;u.unbind=u.off;i.extend(e,u);var p=e.Model=function(t,e){var r=t||{};e||(e={});this.cid=i.uniqueId("c");this.attributes={};if(e.collection)this.collection=e.collection;if(e.parse)r=this.parse(r,e)||{};r=i.defaults({},r,i.result(this,"defaults"));this.set(r,e);this.changed={};this.initialize.apply(this,arguments)};i.extend(p.prototype,u,{changed:null,validationError:null,idAttribute:"id",initialize:function(){},toJSON:function(t){return i.clone(this.attributes)},sync:function(){return e.sync.apply(this,arguments)},get:function(t){return this.attributes[t]},escape:function(t){return i.escape(this.get(t))},has:function(t){return this.get(t)!=null},set:function(t,e,r){var s,n,a,o,h,u,l,c;if(t==null)return this;if(typeof t==="object"){n=t;r=e}else{(n={})[t]=e}r||(r={});if(!this._validate(n,r))return false;a=r.unset;h=r.silent;o=[];u=this._changing;this._changing=true;if(!u){this._previousAttributes=i.clone(this.attributes);this.changed={}}c=this.attributes,l=this._previousAttributes;if(this.idAttribute in n)this.id=n[this.idAttribute];for(s in n){e=n[s];if(!i.isEqual(c[s],e))o.push(s);if(!i.isEqual(l[s],e)){this.changed[s]=e}else{delete this.changed[s]}a?delete c[s]:c[s]=e}if(!h){if(o.length)this._pending=r;for(var f=0,d=o.length;f<d;f++){this.trigger("change:"+o[f],this,c[o[f]],r)}}if(u)return this;if(!h){while(this._pending){r=this._pending;this._pending=false;this.trigger("change",this,r)}}this._pending=false;this._changing=false;return this},unset:function(t,e){return this.set(t,void 0,i.extend({},e,{unset:true}))},clear:function(t){var e={};for(var r in this.attributes)e[r]=void 0;return this.set(e,i.extend({},t,{unset:true}))},hasChanged:function(t){if(t==null)return!i.isEmpty(this.changed);return i.has(this.changed,t)},changedAttributes:function(t){if(!t)return this.hasChanged()?i.clone(this.changed):false;var e,r=false;var s=this._changing?this._previousAttributes:this.attributes;for(var n in t){if(i.isEqual(s[n],e=t[n]))continue;(r||(r={}))[n]=e}return r},previous:function(t){if(t==null||!this._previousAttributes)return null;return this._previousAttributes[t]},previousAttributes:function(){return i.clone(this._previousAttributes)},fetch:function(t){t=t?i.clone(t):{};if(t.parse===void 0)t.parse=true;var e=this;var r=t.success;t.success=function(i){if(!e.set(e.parse(i,t),t))return false;if(r)r(e,i,t);e.trigger("sync",e,i,t)};q(this,t);return this.sync("read",this,t)},save:function(t,e,r){var s,n,a,o=this.attributes;if(t==null||typeof t==="object"){s=t;r=e}else{(s={})[t]=e}r=i.extend({validate:true},r);if(s&&!r.wait){if(!this.set(s,r))return false}else{if(!this._validate(s,r))return false}if(s&&r.wait){this.attributes=i.extend({},o,s)}if(r.parse===void 0)r.parse=true;var h=this;var u=r.success;r.success=function(t){h.attributes=o;var e=h.parse(t,r);if(r.wait)e=i.extend(s||{},e);if(i.isObject(e)&&!h.set(e,r)){return false}if(u)u(h,t,r);h.trigger("sync",h,t,r)};q(this,r);n=this.isNew()?"create":r.patch?"patch":"update";if(n==="patch")r.attrs=s;a=this.sync(n,this,r);if(s&&r.wait)this.attributes=o;return a},destroy:function(t){t=t?i.clone(t):{};var e=this;var r=t.success;var s=function(){e.trigger("destroy",e,e.collection,t)};t.success=function(i){if(t.wait||e.isNew())s();if(r)r(e,i,t);if(!e.isNew())e.trigger("sync",e,i,t)};if(this.isNew()){t.success();return false}q(this,t);var n=this.sync("delete",this,t);if(!t.wait)s();return n},url:function(){var t=i.result(this,"urlRoot")||i.result(this.collection,"url")||M();if(this.isNew())return t;return t.replace(/([^\/])$/,"$1/")+encodeURIComponent(this.id)},parse:function(t,e){return t},clone:function(){return new this.constructor(this.attributes)},isNew:function(){return!this.has(this.idAttribute)},isValid:function(t){return this._validate({},i.extend(t||{},{validate:true}))},_validate:function(t,e){if(!e.validate||!this.validate)return true;t=i.extend({},this.attributes,t);var r=this.validationError=this.validate(t,e)||null;if(!r)return true;this.trigger("invalid",this,r,i.extend(e,{validationError:r}));return false}});var v=["keys","values","pairs","invert","pick","omit"];i.each(v,function(t){p.prototype[t]=function(){var e=o.call(arguments);e.unshift(this.attributes);return i[t].apply(i,e)}});var g=e.Collection=function(t,e){e||(e={});if(e.model)this.model=e.model;if(e.comparator!==void 0)this.comparator=e.comparator;this._reset();this.initialize.apply(this,arguments);if(t)this.reset(t,i.extend({silent:true},e))};var m={add:true,remove:true,merge:true};var y={add:true,remove:false};i.extend(g.prototype,u,{model:p,initialize:function(){},toJSON:function(t){return this.map(function(e){return e.toJSON(t)})},sync:function(){return e.sync.apply(this,arguments)},add:function(t,e){return this.set(t,i.extend({merge:false},e,y))},remove:function(t,e){var r=!i.isArray(t);t=r?[t]:i.clone(t);e||(e={});var s,n,a,o;for(s=0,n=t.length;s<n;s++){o=t[s]=this.get(t[s]);if(!o)continue;delete this._byId[o.id];delete this._byId[o.cid];a=this.indexOf(o);this.models.splice(a,1);this.length--;if(!e.silent){e.index=a;o.trigger("remove",o,this,e)}this._removeReference(o,e)}return r?t[0]:t},set:function(t,e){e=i.defaults({},e,m);if(e.parse)t=this.parse(t,e);var r=!i.isArray(t);t=r?t?[t]:[]:i.clone(t);var s,n,a,o,h,u,l;var c=e.at;var f=this.model;var d=this.comparator&&c==null&&e.sort!==false;var v=i.isString(this.comparator)?this.comparator:null;var g=[],y=[],_={};var b=e.add,w=e.merge,x=e.remove;var E=!d&&b&&x?[]:false;for(s=0,n=t.length;s<n;s++){h=t[s]||{};if(h instanceof p){a=o=h}else{a=h[f.prototype.idAttribute||"id"]}if(u=this.get(a)){if(x)_[u.cid]=true;if(w){h=h===o?o.attributes:h;if(e.parse)h=u.parse(h,e);u.set(h,e);if(d&&!l&&u.hasChanged(v))l=true}t[s]=u}else if(b){o=t[s]=this._prepareModel(h,e);if(!o)continue;g.push(o);this._addReference(o,e)}o=u||o;if(E&&(o.isNew()||!_[o.id]))E.push(o);_[o.id]=true}if(x){for(s=0,n=this.length;s<n;++s){if(!_[(o=this.models[s]).cid])y.push(o)}if(y.length)this.remove(y,e)}if(g.length||E&&E.length){if(d)l=true;this.length+=g.length;if(c!=null){for(s=0,n=g.length;s<n;s++){this.models.splice(c+s,0,g[s])}}else{if(E)this.models.length=0;var k=E||g;for(s=0,n=k.length;s<n;s++){this.models.push(k[s])}}}if(l)this.sort({silent:true});if(!e.silent){for(s=0,n=g.length;s<n;s++){(o=g[s]).trigger("add",o,this,e)}if(l||E&&E.length)this.trigger("sort",this,e)}return r?t[0]:t},reset:function(t,e){e||(e={});for(var r=0,s=this.models.length;r<s;r++){this._removeReference(this.models[r],e)}e.previousModels=this.models;this._reset();t=this.add(t,i.extend({silent:true},e));if(!e.silent)this.trigger("reset",this,e);return t},push:function(t,e){return this.add(t,i.extend({at:this.length},e))},pop:function(t){var e=this.at(this.length-1);this.remove(e,t);return e},unshift:function(t,e){return this.add(t,i.extend({at:0},e))},shift:function(t){var e=this.at(0);this.remove(e,t);return e},slice:function(){return o.apply(this.models,arguments)},get:function(t){if(t==null)return void 0;return this._byId[t]||this._byId[t.id]||this._byId[t.cid]},at:function(t){return this.models[t]},where:function(t,e){if(i.isEmpty(t))return e?void 0:[];return this[e?"find":"filter"](function(e){for(var i in t){if(t[i]!==e.get(i))return false}return true})},findWhere:function(t){return this.where(t,true)},sort:function(t){if(!this.comparator)throw new Error("Cannot sort a set without a comparator");t||(t={});if(i.isString(this.comparator)||this.comparator.length===1){this.models=this.sortBy(this.comparator,this)}else{this.models.sort(i.bind(this.comparator,this))}if(!t.silent)this.trigger("sort",this,t);return this},pluck:function(t){return i.invoke(this.models,"get",t)},fetch:function(t){t=t?i.clone(t):{};if(t.parse===void 0)t.parse=true;var e=t.success;var r=this;t.success=function(i){var s=t.reset?"reset":"set";r[s](i,t);if(e)e(r,i,t);r.trigger("sync",r,i,t)};q(this,t);return this.sync("read",this,t)},create:function(t,e){e=e?i.clone(e):{};if(!(t=this._prepareModel(t,e)))return false;if(!e.wait)this.add(t,e);var r=this;var s=e.success;e.success=function(t,i){if(e.wait)r.add(t,e);if(s)s(t,i,e)};t.save(null,e);return t},parse:function(t,e){return t},clone:function(){return new this.constructor(this.models)},_reset:function(){this.length=0;this.models=[];this._byId={}},_prepareModel:function(t,e){if(t instanceof p)return t;e=e?i.clone(e):{};e.collection=this;var r=new this.model(t,e);if(!r.validationError)return r;this.trigger("invalid",this,r.validationError,e);return false},_addReference:function(t,e){this._byId[t.cid]=t;if(t.id!=null)this._byId[t.id]=t;if(!t.collection)t.collection=this;t.on("all",this._onModelEvent,this)},_removeReference:function(t,e){if(this===t.collection)delete t.collection;t.off("all",this._onModelEvent,this)},_onModelEvent:function(t,e,i,r){if((t==="add"||t==="remove")&&i!==this)return;if(t==="destroy")this.remove(e,r);if(e&&t==="change:"+e.idAttribute){delete this._byId[e.previous(e.idAttribute)];if(e.id!=null)this._byId[e.id]=e}this.trigger.apply(this,arguments)}});var _=["forEach","each","map","collect","reduce","foldl","inject","reduceRight","foldr","find","detect","filter","select","reject","every","all","some","any","include","contains","invoke","max","min","toArray","size","first","head","take","initial","rest","tail","drop","last","without","difference","indexOf","shuffle","lastIndexOf","isEmpty","chain","sample"];i.each(_,function(t){g.prototype[t]=function(){var e=o.call(arguments);e.unshift(this.models);return i[t].apply(i,e)}});var b=["groupBy","countBy","sortBy","indexBy"];i.each(b,function(t){g.prototype[t]=function(e,r){var s=i.isFunction(e)?e:function(t){return t.get(e)};return i[t](this.models,s,r)}});var w=e.View=function(t){this.cid=i.uniqueId("view");t||(t={});i.extend(this,i.pick(t,E));this._ensureElement();this.initialize.apply(this,arguments);this.delegateEvents()};var x=/^(\S+)\s*(.*)$/;var E=["model","collection","el","id","attributes","className","tagName","events"];i.extend(w.prototype,u,{tagName:"div",$:function(t){return this.$el.find(t)},initialize:function(){},render:function(){return this},remove:function(){this.$el.remove();this.stopListening();return this},setElement:function(t,i){if(this.$el)this.undelegateEvents();this.$el=t instanceof e.$?t:e.$(t);this.el=this.$el[0];if(i!==false)this.delegateEvents();return this},delegateEvents:function(t){if(!(t||(t=i.result(this,"events"))))return this;this.undelegateEvents();for(var e in t){var r=t[e];if(!i.isFunction(r))r=this[t[e]];if(!r)continue;var s=e.match(x);var n=s[1],a=s[2];r=i.bind(r,this);n+=".delegateEvents"+this.cid;if(a===""){this.$el.on(n,r)}else{this.$el.on(n,a,r)}}return this},undelegateEvents:function(){this.$el.off(".delegateEvents"+this.cid);return this},_ensureElement:function(){if(!this.el){var t=i.extend({},i.result(this,"attributes"));if(this.id)t.id=i.result(this,"id");if(this.className)t["class"]=i.result(this,"className");var r=e.$("<"+i.result(this,"tagName")+">").attr(t);this.setElement(r,false)}else{this.setElement(i.result(this,"el"),false)}}});e.sync=function(t,r,s){var n=T[t];i.defaults(s||(s={}),{emulateHTTP:e.emulateHTTP,emulateJSON:e.emulateJSON});var a={type:n,dataType:"json"};if(!s.url){a.url=i.result(r,"url")||M()}if(s.data==null&&r&&(t==="create"||t==="update"||t==="patch")){a.contentType="application/json";a.data=JSON.stringify(s.attrs||r.toJSON(s))}if(s.emulateJSON){a.contentType="application/x-www-form-urlencoded";a.data=a.data?{model:a.data}:{}}if(s.emulateHTTP&&(n==="PUT"||n==="DELETE"||n==="PATCH")){a.type="POST";if(s.emulateJSON)a.data._method=n;var o=s.beforeSend;s.beforeSend=function(t){t.setRequestHeader("X-HTTP-Method-Override",n);if(o)return o.apply(this,arguments)}}if(a.type!=="GET"&&!s.emulateJSON){a.processData=false}if(a.type==="PATCH"&&k){a.xhr=function(){return new ActiveXObject("Microsoft.XMLHTTP")}}var h=s.xhr=e.ajax(i.extend(a,s));r.trigger("request",r,h,s);return h};var k=typeof window!=="undefined"&&!!window.ActiveXObject&&!(window.XMLHttpRequest&&(new XMLHttpRequest).dispatchEvent);var T={create:"POST",update:"PUT",patch:"PATCH","delete":"DELETE",read:"GET"};e.ajax=function(){return e.$.ajax.apply(e.$,arguments)};var $=e.Router=function(t){t||(t={});if(t.routes)this.routes=t.routes;this._bindRoutes();this.initialize.apply(this,arguments)};var S=/\((.*?)\)/g;var H=/(\(\?)?:\w+/g;var A=/\*\w+/g;var I=/[\-{}\[\]+?.,\\\^$|#\s]/g;i.extend($.prototype,u,{initialize:function(){},route:function(t,r,s){if(!i.isRegExp(t))t=this._routeToRegExp(t);if(i.isFunction(r)){s=r;r=""}if(!s)s=this[r];var n=this;e.history.route(t,function(i){var a=n._extractParameters(t,i);n.execute(s,a);n.trigger.apply(n,["route:"+r].concat(a));n.trigger("route",r,a);e.history.trigger("route",n,r,a)});return this},execute:function(t,e){if(t)t.apply(this,e)},navigate:function(t,i){e.history.navigate(t,i);return this},_bindRoutes:function(){if(!this.routes)return;this.routes=i.result(this,"routes");var t,e=i.keys(this.routes);while((t=e.pop())!=null){this.route(t,this.routes[t])}},_routeToRegExp:function(t){t=t.replace(I,"\\$&").replace(S,"(?:$1)?").replace(H,function(t,e){return e?t:"([^/?]+)"}).replace(A,"([^?]*?)");return new RegExp("^"+t+"(?:\\?([\\s\\S]*))?$")},_extractParameters:function(t,e){var r=t.exec(e).slice(1);return i.map(r,function(t,e){if(e===r.length-1)return t||null;return t?decodeURIComponent(t):null})}});var N=e.History=function(){this.handlers=[];i.bindAll(this,"checkUrl");if(typeof window!=="undefined"){this.location=window.location;this.history=window.history}};var R=/^[#\/]|\s+$/g;var O=/^\/+|\/+$/g;var P=/msie [\w.]+/;var C=/\/$/;var j=/#.*$/;N.started=false;i.extend(N.prototype,u,{interval:50,atRoot:function(){return this.location.pathname.replace(/[^\/]$/,"$&/")===this.root},getHash:function(t){var e=(t||this).location.href.match(/#(.*)$/);return e?e[1]:""},getFragment:function(t,e){if(t==null){if(this._hasPushState||!this._wantsHashChange||e){t=decodeURI(this.location.pathname+this.location.search);var i=this.root.replace(C,"");if(!t.indexOf(i))t=t.slice(i.length)}else{t=this.getHash()}}return t.replace(R,"")},start:function(t){if(N.started)throw new Error("Backbone.history has already been started");N.started=true;this.options=i.extend({root:"/"},this.options,t);this.root=this.options.root;this._wantsHashChange=this.options.hashChange!==false;this._wantsPushState=!!this.options.pushState;this._hasPushState=!!(this.options.pushState&&this.history&&this.history.pushState);var r=this.getFragment();var s=document.documentMode;var n=P.exec(navigator.userAgent.toLowerCase())&&(!s||s<=7);this.root=("/"+this.root+"/").replace(O,"/");if(n&&this._wantsHashChange){var a=e.$('<iframe src="javascript:0" tabindex="-1">');this.iframe=a.hide().appendTo("body")[0].contentWindow;this.navigate(r)}if(this._hasPushState){e.$(window).on("popstate",this.checkUrl)}else if(this._wantsHashChange&&"onhashchange"in window&&!n){e.$(window).on("hashchange",this.checkUrl)}else if(this._wantsHashChange){this._checkUrlInterval=setInterval(this.checkUrl,this.interval)}this.fragment=r;var o=this.location;if(this._wantsHashChange&&this._wantsPushState){if(!this._hasPushState&&!this.atRoot()){this.fragment=this.getFragment(null,true);this.location.replace(this.root+"#"+this.fragment);return true}else if(this._hasPushState&&this.atRoot()&&o.hash){this.fragment=this.getHash().replace(R,"");this.history.replaceState({},document.title,this.root+this.fragment)}}if(!this.options.silent)return this.loadUrl()},stop:function(){e.$(window).off("popstate",this.checkUrl).off("hashchange",this.checkUrl);if(this._checkUrlInterval)clearInterval(this._checkUrlInterval);N.started=false},route:function(t,e){this.handlers.unshift({route:t,callback:e})},checkUrl:function(t){var e=this.getFragment();if(e===this.fragment&&this.iframe){e=this.getFragment(this.getHash(this.iframe))}if(e===this.fragment)return false;if(this.iframe)this.navigate(e);this.loadUrl()},loadUrl:function(t){t=this.fragment=this.getFragment(t);return i.any(this.handlers,function(e){if(e.route.test(t)){e.callback(t);return true}})},navigate:function(t,e){if(!N.started)return false;if(!e||e===true)e={trigger:!!e};var i=this.root+(t=this.getFragment(t||""));t=t.replace(j,"");if(this.fragment===t)return;this.fragment=t;if(t===""&&i!=="/")i=i.slice(0,-1);if(this._hasPushState){this.history[e.replace?"replaceState":"pushState"]({},document.title,i)}else if(this._wantsHashChange){this._updateHash(this.location,t,e.replace);if(this.iframe&&t!==this.getFragment(this.getHash(this.iframe))){if(!e.replace)this.iframe.document.open().close();this._updateHash(this.iframe.location,t,e.replace)}}else{return this.location.assign(i)}if(e.trigger)return this.loadUrl(t)},_updateHash:function(t,e,i){if(i){var r=t.href.replace(/(javascript:|#).*$/,"");t.replace(r+"#"+e)}else{t.hash="#"+e}}});e.history=new N;var U=function(t,e){var r=this;var s;if(t&&i.has(t,"constructor")){s=t.constructor}else{s=function(){return r.apply(this,arguments)}}i.extend(s,r,e);var n=function(){this.constructor=s};n.prototype=r.prototype;s.prototype=new n;if(t)i.extend(s.prototype,t);s.__super__=r.prototype;return s};p.extend=g.extend=$.extend=w.extend=N.extend=U;var M=function(){throw new Error('A "url" property or function must be specified')};var q=function(t,e){var i=e.error;e.error=function(r){if(i)i(t,r,e);t.trigger("error",t,r,e)}};return e});
//# sourceMappingURL=backbone-min.map

/**
 * @author mrdoob / http://mrdoob.com/
 */

var EventDispatcher = function () {}

EventDispatcher.prototype = {

	constructor: EventDispatcher,

	apply: function ( object ) {

		object.addEventListener = EventDispatcher.prototype.addEventListener;
		object.hasEventListener = EventDispatcher.prototype.hasEventListener;
		object.removeEventListener = EventDispatcher.prototype.removeEventListener;
		object.dispatchEvent = EventDispatcher.prototype.dispatchEvent;

	},

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

		    //dispatch before pushing so that a listeneradded listener does not trigger itself
			this.dispatchEvent( { type: 'listeneradded', listenerType: type, listener: listener } );

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

			return true;

		}

		return false;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			    this.dispatchEvent( { type: 'listenerremoved', listenerType: type, listener: listener } );
			    //dispatch after splicing so that a listenerremoved listener does not trigger itself
			}

		}

	},

	dispatchEvent: function ( event ) {
			
		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			var array = [];
			var length = listenerArray.length;

			for ( var i = 0; i < length; i ++ ) {

				array[ i ] = listenerArray[ i ];

			}

			for ( var i = 0; i < length; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

};

//
// Autogenerated by Thrift Compiler (0.9.3-GFODOR)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//


ThreeJSSceneObject = function(args) {
  this.MeshId = null;
  this.PositionX = null;
  this.PositionY = null;
  this.PositionZ = null;
  this.RotationX = null;
  this.RotationY = null;
  this.RotationZ = null;
  this.RotationW = null;
  this.ScaleX = null;
  this.ScaleY = null;
  this.ScaleZ = null;
  this.IsVisible = null;
  if (args) {
    if (args.MeshId !== undefined && args.MeshId !== null) {
      this.MeshId = args.MeshId;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field MeshId is unset!');
    }
    if (args.PositionX !== undefined && args.PositionX !== null) {
      this.PositionX = args.PositionX;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field PositionX is unset!');
    }
    if (args.PositionY !== undefined && args.PositionY !== null) {
      this.PositionY = args.PositionY;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field PositionY is unset!');
    }
    if (args.PositionZ !== undefined && args.PositionZ !== null) {
      this.PositionZ = args.PositionZ;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field PositionZ is unset!');
    }
    if (args.RotationX !== undefined && args.RotationX !== null) {
      this.RotationX = args.RotationX;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field RotationX is unset!');
    }
    if (args.RotationY !== undefined && args.RotationY !== null) {
      this.RotationY = args.RotationY;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field RotationY is unset!');
    }
    if (args.RotationZ !== undefined && args.RotationZ !== null) {
      this.RotationZ = args.RotationZ;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field RotationZ is unset!');
    }
    if (args.RotationW !== undefined && args.RotationW !== null) {
      this.RotationW = args.RotationW;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field RotationW is unset!');
    }
    if (args.ScaleX !== undefined && args.ScaleX !== null) {
      this.ScaleX = args.ScaleX;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field ScaleX is unset!');
    }
    if (args.ScaleY !== undefined && args.ScaleY !== null) {
      this.ScaleY = args.ScaleY;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field ScaleY is unset!');
    }
    if (args.ScaleZ !== undefined && args.ScaleZ !== null) {
      this.ScaleZ = args.ScaleZ;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field ScaleZ is unset!');
    }
    if (args.IsVisible !== undefined && args.IsVisible !== null) {
      this.IsVisible = args.IsVisible;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field IsVisible is unset!');
    }
  }
};
ThreeJSSceneObject.prototype = {};
ThreeJSSceneObject.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.MeshId = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.DOUBLE) {
        this.PositionX = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.DOUBLE) {
        this.PositionY = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.DOUBLE) {
        this.PositionZ = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.DOUBLE) {
        this.RotationX = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.DOUBLE) {
        this.RotationY = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.DOUBLE) {
        this.RotationZ = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.DOUBLE) {
        this.RotationW = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.DOUBLE) {
        this.ScaleX = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.DOUBLE) {
        this.ScaleY = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 11:
      if (ftype == Thrift.Type.DOUBLE) {
        this.ScaleZ = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 12:
      if (ftype == Thrift.Type.BOOL) {
        this.IsVisible = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ThreeJSSceneObject.prototype.write = function(output) {
  output.writeStructBegin('ThreeJSSceneObject');
  if (this.MeshId !== null && this.MeshId !== undefined) {
    output.writeFieldBegin('MeshId', Thrift.Type.I32, 1);
    output.writeI32(this.MeshId);
    output.writeFieldEnd();
  }
  if (this.PositionX !== null && this.PositionX !== undefined) {
    output.writeFieldBegin('PositionX', Thrift.Type.DOUBLE, 2);
    output.writeDouble(this.PositionX);
    output.writeFieldEnd();
  }
  if (this.PositionY !== null && this.PositionY !== undefined) {
    output.writeFieldBegin('PositionY', Thrift.Type.DOUBLE, 3);
    output.writeDouble(this.PositionY);
    output.writeFieldEnd();
  }
  if (this.PositionZ !== null && this.PositionZ !== undefined) {
    output.writeFieldBegin('PositionZ', Thrift.Type.DOUBLE, 4);
    output.writeDouble(this.PositionZ);
    output.writeFieldEnd();
  }
  if (this.RotationX !== null && this.RotationX !== undefined) {
    output.writeFieldBegin('RotationX', Thrift.Type.DOUBLE, 5);
    output.writeDouble(this.RotationX);
    output.writeFieldEnd();
  }
  if (this.RotationY !== null && this.RotationY !== undefined) {
    output.writeFieldBegin('RotationY', Thrift.Type.DOUBLE, 6);
    output.writeDouble(this.RotationY);
    output.writeFieldEnd();
  }
  if (this.RotationZ !== null && this.RotationZ !== undefined) {
    output.writeFieldBegin('RotationZ', Thrift.Type.DOUBLE, 7);
    output.writeDouble(this.RotationZ);
    output.writeFieldEnd();
  }
  if (this.RotationW !== null && this.RotationW !== undefined) {
    output.writeFieldBegin('RotationW', Thrift.Type.DOUBLE, 8);
    output.writeDouble(this.RotationW);
    output.writeFieldEnd();
  }
  if (this.ScaleX !== null && this.ScaleX !== undefined) {
    output.writeFieldBegin('ScaleX', Thrift.Type.DOUBLE, 9);
    output.writeDouble(this.ScaleX);
    output.writeFieldEnd();
  }
  if (this.ScaleY !== null && this.ScaleY !== undefined) {
    output.writeFieldBegin('ScaleY', Thrift.Type.DOUBLE, 10);
    output.writeDouble(this.ScaleY);
    output.writeFieldEnd();
  }
  if (this.ScaleZ !== null && this.ScaleZ !== undefined) {
    output.writeFieldBegin('ScaleZ', Thrift.Type.DOUBLE, 11);
    output.writeDouble(this.ScaleZ);
    output.writeFieldEnd();
  }
  if (this.IsVisible !== null && this.IsVisible !== undefined) {
    output.writeFieldBegin('IsVisible', Thrift.Type.BOOL, 12);
    output.writeBool(this.IsVisible);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ThreeJSGeometryData = function(args) {
  this.Vertices = null;
  this.Faces = null;
  this.Uvs = null;
  this.Uvs2 = null;
  this.IsBufferedGeometry = null;
  this.Colors = null;
  if (args) {
    if (args.Vertices !== undefined && args.Vertices !== null) {
      this.Vertices = Thrift.copyList(args.Vertices, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Vertices is unset!');
    }
    if (args.Faces !== undefined && args.Faces !== null) {
      this.Faces = Thrift.copyList(args.Faces, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Faces is unset!');
    }
    if (args.Uvs !== undefined && args.Uvs !== null) {
      this.Uvs = Thrift.copyList(args.Uvs, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Uvs is unset!');
    }
    if (args.Uvs2 !== undefined && args.Uvs2 !== null) {
      this.Uvs2 = Thrift.copyList(args.Uvs2, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Uvs2 is unset!');
    }
    if (args.IsBufferedGeometry !== undefined && args.IsBufferedGeometry !== null) {
      this.IsBufferedGeometry = args.IsBufferedGeometry;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field IsBufferedGeometry is unset!');
    }
    if (args.Colors !== undefined && args.Colors !== null) {
      this.Colors = Thrift.copyList(args.Colors, [null]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Colors is unset!');
    }
  }
};
ThreeJSGeometryData.prototype = {};
ThreeJSGeometryData.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        var _size0 = 0;
        var _rtmp34;
        this.Vertices = [];
        var _etype3 = 0;
        _rtmp34 = input.readListBegin();
        _etype3 = _rtmp34.etype;
        _size0 = _rtmp34.size;
        for (var _i5 = 0; _i5 < _size0; ++_i5)
        {
          var elem6 = null;
          elem6 = input.readDouble().value;
          this.Vertices.push(elem6);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        var _size7 = 0;
        var _rtmp311;
        this.Faces = [];
        var _etype10 = 0;
        _rtmp311 = input.readListBegin();
        _etype10 = _rtmp311.etype;
        _size7 = _rtmp311.size;
        for (var _i12 = 0; _i12 < _size7; ++_i12)
        {
          var elem13 = null;
          elem13 = input.readI32().value;
          this.Faces.push(elem13);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        var _size14 = 0;
        var _rtmp318;
        this.Uvs = [];
        var _etype17 = 0;
        _rtmp318 = input.readListBegin();
        _etype17 = _rtmp318.etype;
        _size14 = _rtmp318.size;
        for (var _i19 = 0; _i19 < _size14; ++_i19)
        {
          var elem20 = null;
          elem20 = input.readDouble().value;
          this.Uvs.push(elem20);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.LIST) {
        var _size21 = 0;
        var _rtmp325;
        this.Uvs2 = [];
        var _etype24 = 0;
        _rtmp325 = input.readListBegin();
        _etype24 = _rtmp325.etype;
        _size21 = _rtmp325.size;
        for (var _i26 = 0; _i26 < _size21; ++_i26)
        {
          var elem27 = null;
          elem27 = input.readDouble().value;
          this.Uvs2.push(elem27);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.BOOL) {
        this.IsBufferedGeometry = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.LIST) {
        var _size28 = 0;
        var _rtmp332;
        this.Colors = [];
        var _etype31 = 0;
        _rtmp332 = input.readListBegin();
        _etype31 = _rtmp332.etype;
        _size28 = _rtmp332.size;
        for (var _i33 = 0; _i33 < _size28; ++_i33)
        {
          var elem34 = null;
          elem34 = input.readDouble().value;
          this.Colors.push(elem34);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ThreeJSGeometryData.prototype.write = function(output) {
  output.writeStructBegin('ThreeJSGeometryData');
  if (this.Vertices !== null && this.Vertices !== undefined) {
    output.writeFieldBegin('Vertices', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.DOUBLE, this.Vertices.length);
    for (var iter35 in this.Vertices)
    {
      if (this.Vertices.hasOwnProperty(iter35))
      {
        iter35 = this.Vertices[iter35];
        output.writeDouble(iter35);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.Faces !== null && this.Faces !== undefined) {
    output.writeFieldBegin('Faces', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.I32, this.Faces.length);
    for (var iter36 in this.Faces)
    {
      if (this.Faces.hasOwnProperty(iter36))
      {
        iter36 = this.Faces[iter36];
        output.writeI32(iter36);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.Uvs !== null && this.Uvs !== undefined) {
    output.writeFieldBegin('Uvs', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.DOUBLE, this.Uvs.length);
    for (var iter37 in this.Uvs)
    {
      if (this.Uvs.hasOwnProperty(iter37))
      {
        iter37 = this.Uvs[iter37];
        output.writeDouble(iter37);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.Uvs2 !== null && this.Uvs2 !== undefined) {
    output.writeFieldBegin('Uvs2', Thrift.Type.LIST, 4);
    output.writeListBegin(Thrift.Type.DOUBLE, this.Uvs2.length);
    for (var iter38 in this.Uvs2)
    {
      if (this.Uvs2.hasOwnProperty(iter38))
      {
        iter38 = this.Uvs2[iter38];
        output.writeDouble(iter38);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.IsBufferedGeometry !== null && this.IsBufferedGeometry !== undefined) {
    output.writeFieldBegin('IsBufferedGeometry', Thrift.Type.BOOL, 5);
    output.writeBool(this.IsBufferedGeometry);
    output.writeFieldEnd();
  }
  if (this.Colors !== null && this.Colors !== undefined) {
    output.writeFieldBegin('Colors', Thrift.Type.LIST, 6);
    output.writeListBegin(Thrift.Type.DOUBLE, this.Colors.length);
    for (var iter39 in this.Colors)
    {
      if (this.Colors.hasOwnProperty(iter39))
      {
        iter39 = this.Colors[iter39];
        output.writeDouble(iter39);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ThreeJSGeometry = function(args) {
  this.Uuid = null;
  this.Data = null;
  if (args) {
    if (args.Uuid !== undefined && args.Uuid !== null) {
      this.Uuid = args.Uuid;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Uuid is unset!');
    }
    if (args.Data !== undefined && args.Data !== null) {
      this.Data = new ThreeJSGeometryData(args.Data);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Data is unset!');
    }
  }
};
ThreeJSGeometry.prototype = {};
ThreeJSGeometry.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.Uuid = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRUCT) {
        this.Data = new ThreeJSGeometryData();
        this.Data.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ThreeJSGeometry.prototype.write = function(output) {
  output.writeStructBegin('ThreeJSGeometry');
  if (this.Uuid !== null && this.Uuid !== undefined) {
    output.writeFieldBegin('Uuid', Thrift.Type.STRING, 1);
    output.writeString(this.Uuid);
    output.writeFieldEnd();
  }
  if (this.Data !== null && this.Data !== undefined) {
    output.writeFieldBegin('Data', Thrift.Type.STRUCT, 2);
    this.Data.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ThreeJSMaterial = function(args) {
  this.Uuid = null;
  this.Visible = null;
  this.Color = null;
  this.Side = null;
  this.Transparent = null;
  this.Opacity = null;
  this.Map = null;
  this.LightMap = null;
  this.LightMapIntensity = null;
  if (args) {
    if (args.Uuid !== undefined && args.Uuid !== null) {
      this.Uuid = args.Uuid;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Uuid is unset!');
    }
    if (args.Visible !== undefined && args.Visible !== null) {
      this.Visible = args.Visible;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Visible is unset!');
    }
    if (args.Color !== undefined && args.Color !== null) {
      this.Color = args.Color;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Color is unset!');
    }
    if (args.Side !== undefined && args.Side !== null) {
      this.Side = args.Side;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Side is unset!');
    }
    if (args.Transparent !== undefined && args.Transparent !== null) {
      this.Transparent = args.Transparent;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Transparent is unset!');
    }
    if (args.Opacity !== undefined && args.Opacity !== null) {
      this.Opacity = args.Opacity;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Opacity is unset!');
    }
    if (args.Map !== undefined && args.Map !== null) {
      this.Map = args.Map;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Map is unset!');
    }
    if (args.LightMap !== undefined && args.LightMap !== null) {
      this.LightMap = args.LightMap;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field LightMap is unset!');
    }
    if (args.LightMapIntensity !== undefined && args.LightMapIntensity !== null) {
      this.LightMapIntensity = args.LightMapIntensity;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field LightMapIntensity is unset!');
    }
  }
};
ThreeJSMaterial.prototype = {};
ThreeJSMaterial.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.Uuid = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.BOOL) {
        this.Visible = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.Color = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.BYTE) {
        this.Side = input.readByte().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.BOOL) {
        this.Transparent = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.DOUBLE) {
        this.Opacity = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.STRING) {
        this.Map = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.STRING) {
        this.LightMap = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.DOUBLE) {
        this.LightMapIntensity = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ThreeJSMaterial.prototype.write = function(output) {
  output.writeStructBegin('ThreeJSMaterial');
  if (this.Uuid !== null && this.Uuid !== undefined) {
    output.writeFieldBegin('Uuid', Thrift.Type.STRING, 1);
    output.writeString(this.Uuid);
    output.writeFieldEnd();
  }
  if (this.Visible !== null && this.Visible !== undefined) {
    output.writeFieldBegin('Visible', Thrift.Type.BOOL, 2);
    output.writeBool(this.Visible);
    output.writeFieldEnd();
  }
  if (this.Color !== null && this.Color !== undefined) {
    output.writeFieldBegin('Color', Thrift.Type.I32, 3);
    output.writeI32(this.Color);
    output.writeFieldEnd();
  }
  if (this.Side !== null && this.Side !== undefined) {
    output.writeFieldBegin('Side', Thrift.Type.BYTE, 4);
    output.writeByte(this.Side);
    output.writeFieldEnd();
  }
  if (this.Transparent !== null && this.Transparent !== undefined) {
    output.writeFieldBegin('Transparent', Thrift.Type.BOOL, 5);
    output.writeBool(this.Transparent);
    output.writeFieldEnd();
  }
  if (this.Opacity !== null && this.Opacity !== undefined) {
    output.writeFieldBegin('Opacity', Thrift.Type.DOUBLE, 6);
    output.writeDouble(this.Opacity);
    output.writeFieldEnd();
  }
  if (this.Map !== null && this.Map !== undefined) {
    output.writeFieldBegin('Map', Thrift.Type.STRING, 7);
    output.writeString(this.Map);
    output.writeFieldEnd();
  }
  if (this.LightMap !== null && this.LightMap !== undefined) {
    output.writeFieldBegin('LightMap', Thrift.Type.STRING, 8);
    output.writeString(this.LightMap);
    output.writeFieldEnd();
  }
  if (this.LightMapIntensity !== null && this.LightMapIntensity !== undefined) {
    output.writeFieldBegin('LightMapIntensity', Thrift.Type.DOUBLE, 9);
    output.writeDouble(this.LightMapIntensity);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ThreeJSTexture = function(args) {
  this.Uuid = null;
  this.SourceHash = null;
  this.Src = null;
  this.TextureDataUri = null;
  this.FlipY = null;
  this.OffsetX = null;
  this.OffsetY = null;
  this.RepeatX = null;
  this.RepeatY = null;
  this.WrapS = null;
  if (args) {
    if (args.Uuid !== undefined && args.Uuid !== null) {
      this.Uuid = args.Uuid;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Uuid is unset!');
    }
    if (args.SourceHash !== undefined && args.SourceHash !== null) {
      this.SourceHash = args.SourceHash;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field SourceHash is unset!');
    }
    if (args.Src !== undefined && args.Src !== null) {
      this.Src = args.Src;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Src is unset!');
    }
    if (args.TextureDataUri !== undefined && args.TextureDataUri !== null) {
      this.TextureDataUri = args.TextureDataUri;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field TextureDataUri is unset!');
    }
    if (args.FlipY !== undefined && args.FlipY !== null) {
      this.FlipY = args.FlipY;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field FlipY is unset!');
    }
    if (args.OffsetX !== undefined && args.OffsetX !== null) {
      this.OffsetX = args.OffsetX;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field OffsetX is unset!');
    }
    if (args.OffsetY !== undefined && args.OffsetY !== null) {
      this.OffsetY = args.OffsetY;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field OffsetY is unset!');
    }
    if (args.RepeatX !== undefined && args.RepeatX !== null) {
      this.RepeatX = args.RepeatX;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field RepeatX is unset!');
    }
    if (args.RepeatY !== undefined && args.RepeatY !== null) {
      this.RepeatY = args.RepeatY;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field RepeatY is unset!');
    }
    if (args.WrapS !== undefined && args.WrapS !== null) {
      this.WrapS = args.WrapS;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field WrapS is unset!');
    }
  }
};
ThreeJSTexture.prototype = {};
ThreeJSTexture.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.Uuid = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I64) {
        this.SourceHash = input.readI64().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.Src = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRING) {
        this.TextureDataUri = input.readBinary().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.BOOL) {
        this.FlipY = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.DOUBLE) {
        this.OffsetX = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.DOUBLE) {
        this.OffsetY = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.DOUBLE) {
        this.RepeatX = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.DOUBLE) {
        this.RepeatY = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.I16) {
        this.WrapS = input.readI16().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ThreeJSTexture.prototype.write = function(output) {
  output.writeStructBegin('ThreeJSTexture');
  if (this.Uuid !== null && this.Uuid !== undefined) {
    output.writeFieldBegin('Uuid', Thrift.Type.STRING, 1);
    output.writeString(this.Uuid);
    output.writeFieldEnd();
  }
  if (this.SourceHash !== null && this.SourceHash !== undefined) {
    output.writeFieldBegin('SourceHash', Thrift.Type.I64, 2);
    output.writeI64(this.SourceHash);
    output.writeFieldEnd();
  }
  if (this.Src !== null && this.Src !== undefined) {
    output.writeFieldBegin('Src', Thrift.Type.STRING, 3);
    output.writeString(this.Src);
    output.writeFieldEnd();
  }
  if (this.TextureDataUri !== null && this.TextureDataUri !== undefined) {
    output.writeFieldBegin('TextureDataUri', Thrift.Type.STRING, 4);
    output.writeBinary(this.TextureDataUri);
    output.writeFieldEnd();
  }
  if (this.FlipY !== null && this.FlipY !== undefined) {
    output.writeFieldBegin('FlipY', Thrift.Type.BOOL, 5);
    output.writeBool(this.FlipY);
    output.writeFieldEnd();
  }
  if (this.OffsetX !== null && this.OffsetX !== undefined) {
    output.writeFieldBegin('OffsetX', Thrift.Type.DOUBLE, 6);
    output.writeDouble(this.OffsetX);
    output.writeFieldEnd();
  }
  if (this.OffsetY !== null && this.OffsetY !== undefined) {
    output.writeFieldBegin('OffsetY', Thrift.Type.DOUBLE, 7);
    output.writeDouble(this.OffsetY);
    output.writeFieldEnd();
  }
  if (this.RepeatX !== null && this.RepeatX !== undefined) {
    output.writeFieldBegin('RepeatX', Thrift.Type.DOUBLE, 8);
    output.writeDouble(this.RepeatX);
    output.writeFieldEnd();
  }
  if (this.RepeatY !== null && this.RepeatY !== undefined) {
    output.writeFieldBegin('RepeatY', Thrift.Type.DOUBLE, 9);
    output.writeDouble(this.RepeatY);
    output.writeFieldEnd();
  }
  if (this.WrapS !== null && this.WrapS !== undefined) {
    output.writeFieldBegin('WrapS', Thrift.Type.I16, 10);
    output.writeI16(this.WrapS);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ThreeJSColliderFlags = function(args) {
  this.Enabled = null;
  if (args) {
    if (args.Enabled !== undefined && args.Enabled !== null) {
      this.Enabled = args.Enabled;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Enabled is unset!');
    }
  }
};
ThreeJSColliderFlags.prototype = {};
ThreeJSColliderFlags.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.BOOL) {
        this.Enabled = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ThreeJSColliderFlags.prototype.write = function(output) {
  output.writeStructBegin('ThreeJSColliderFlags');
  if (this.Enabled !== null && this.Enabled !== undefined) {
    output.writeFieldBegin('Enabled', Thrift.Type.BOOL, 1);
    output.writeBool(this.Enabled);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ThreeJSAltspaceFlags = function(args) {
  this.ColliderFlags = null;
  if (args) {
    if (args.ColliderFlags !== undefined && args.ColliderFlags !== null) {
      this.ColliderFlags = new ThreeJSColliderFlags(args.ColliderFlags);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field ColliderFlags is unset!');
    }
  }
};
ThreeJSAltspaceFlags.prototype = {};
ThreeJSAltspaceFlags.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRUCT) {
        this.ColliderFlags = new ThreeJSColliderFlags();
        this.ColliderFlags.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 0:
        input.skip(ftype);
        break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ThreeJSAltspaceFlags.prototype.write = function(output) {
  output.writeStructBegin('ThreeJSAltspaceFlags');
  if (this.ColliderFlags !== null && this.ColliderFlags !== undefined) {
    output.writeFieldBegin('ColliderFlags', Thrift.Type.STRUCT, 1);
    this.ColliderFlags.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ThreeJSMesh = function(args) {
  this.MeshId = null;
  this.Geometry = null;
  this.Material = null;
  this.AltspaceFlags = null;
  if (args) {
    if (args.MeshId !== undefined && args.MeshId !== null) {
      this.MeshId = args.MeshId;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field MeshId is unset!');
    }
    if (args.Geometry !== undefined && args.Geometry !== null) {
      this.Geometry = args.Geometry;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Geometry is unset!');
    }
    if (args.Material !== undefined && args.Material !== null) {
      this.Material = args.Material;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Material is unset!');
    }
    if (args.AltspaceFlags !== undefined && args.AltspaceFlags !== null) {
      this.AltspaceFlags = new ThreeJSAltspaceFlags(args.AltspaceFlags);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field AltspaceFlags is unset!');
    }
  }
};
ThreeJSMesh.prototype = {};
ThreeJSMesh.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.I32) {
        this.MeshId = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.STRING) {
        this.Geometry = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRING) {
        this.Material = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.AltspaceFlags = new ThreeJSAltspaceFlags();
        this.AltspaceFlags.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ThreeJSMesh.prototype.write = function(output) {
  output.writeStructBegin('ThreeJSMesh');
  if (this.MeshId !== null && this.MeshId !== undefined) {
    output.writeFieldBegin('MeshId', Thrift.Type.I32, 1);
    output.writeI32(this.MeshId);
    output.writeFieldEnd();
  }
  if (this.Geometry !== null && this.Geometry !== undefined) {
    output.writeFieldBegin('Geometry', Thrift.Type.STRING, 2);
    output.writeString(this.Geometry);
    output.writeFieldEnd();
  }
  if (this.Material !== null && this.Material !== undefined) {
    output.writeFieldBegin('Material', Thrift.Type.STRING, 3);
    output.writeString(this.Material);
    output.writeFieldEnd();
  }
  if (this.AltspaceFlags !== null && this.AltspaceFlags !== undefined) {
    output.writeFieldBegin('AltspaceFlags', Thrift.Type.STRUCT, 4);
    this.AltspaceFlags.write(output);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ThreeJSScene = function(args) {
  this.Geometries = null;
  this.Materials = null;
  this.Meshes = null;
  this.Textures = null;
  this.Initialized = null;
  if (args) {
    if (args.Geometries !== undefined && args.Geometries !== null) {
      this.Geometries = Thrift.copyList(args.Geometries, [ThreeJSGeometry]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Geometries is unset!');
    }
    if (args.Materials !== undefined && args.Materials !== null) {
      this.Materials = Thrift.copyList(args.Materials, [ThreeJSMaterial]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Materials is unset!');
    }
    if (args.Meshes !== undefined && args.Meshes !== null) {
      this.Meshes = Thrift.copyList(args.Meshes, [ThreeJSMesh]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Meshes is unset!');
    }
    if (args.Textures !== undefined && args.Textures !== null) {
      this.Textures = Thrift.copyList(args.Textures, [ThreeJSTexture]);
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Textures is unset!');
    }
    if (args.Initialized !== undefined && args.Initialized !== null) {
      this.Initialized = args.Initialized;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Initialized is unset!');
    }
  }
};
ThreeJSScene.prototype = {};
ThreeJSScene.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        var _size40 = 0;
        var _rtmp344;
        this.Geometries = [];
        var _etype43 = 0;
        _rtmp344 = input.readListBegin();
        _etype43 = _rtmp344.etype;
        _size40 = _rtmp344.size;
        for (var _i45 = 0; _i45 < _size40; ++_i45)
        {
          var elem46 = null;
          elem46 = new ThreeJSGeometry();
          elem46.read(input);
          this.Geometries.push(elem46);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        var _size47 = 0;
        var _rtmp351;
        this.Materials = [];
        var _etype50 = 0;
        _rtmp351 = input.readListBegin();
        _etype50 = _rtmp351.etype;
        _size47 = _rtmp351.size;
        for (var _i52 = 0; _i52 < _size47; ++_i52)
        {
          var elem53 = null;
          elem53 = new ThreeJSMaterial();
          elem53.read(input);
          this.Materials.push(elem53);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.LIST) {
        var _size54 = 0;
        var _rtmp358;
        this.Meshes = [];
        var _etype57 = 0;
        _rtmp358 = input.readListBegin();
        _etype57 = _rtmp358.etype;
        _size54 = _rtmp358.size;
        for (var _i59 = 0; _i59 < _size54; ++_i59)
        {
          var elem60 = null;
          elem60 = new ThreeJSMesh();
          elem60.read(input);
          this.Meshes.push(elem60);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.LIST) {
        var _size61 = 0;
        var _rtmp365;
        this.Textures = [];
        var _etype64 = 0;
        _rtmp365 = input.readListBegin();
        _etype64 = _rtmp365.etype;
        _size61 = _rtmp365.size;
        for (var _i66 = 0; _i66 < _size61; ++_i66)
        {
          var elem67 = null;
          elem67 = new ThreeJSTexture();
          elem67.read(input);
          this.Textures.push(elem67);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.BOOL) {
        this.Initialized = input.readBool().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ThreeJSScene.prototype.write = function(output) {
  output.writeStructBegin('ThreeJSScene');
  if (this.Geometries !== null && this.Geometries !== undefined) {
    output.writeFieldBegin('Geometries', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.Geometries.length);
    for (var iter68 in this.Geometries)
    {
      if (this.Geometries.hasOwnProperty(iter68))
      {
        iter68 = this.Geometries[iter68];
        iter68.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.Materials !== null && this.Materials !== undefined) {
    output.writeFieldBegin('Materials', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.STRUCT, this.Materials.length);
    for (var iter69 in this.Materials)
    {
      if (this.Materials.hasOwnProperty(iter69))
      {
        iter69 = this.Materials[iter69];
        iter69.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.Meshes !== null && this.Meshes !== undefined) {
    output.writeFieldBegin('Meshes', Thrift.Type.LIST, 3);
    output.writeListBegin(Thrift.Type.STRUCT, this.Meshes.length);
    for (var iter70 in this.Meshes)
    {
      if (this.Meshes.hasOwnProperty(iter70))
      {
        iter70 = this.Meshes[iter70];
        iter70.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.Textures !== null && this.Textures !== undefined) {
    output.writeFieldBegin('Textures', Thrift.Type.LIST, 4);
    output.writeListBegin(Thrift.Type.STRUCT, this.Textures.length);
    for (var iter71 in this.Textures)
    {
      if (this.Textures.hasOwnProperty(iter71))
      {
        iter71 = this.Textures[iter71];
        iter71.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.Initialized !== null && this.Initialized !== undefined) {
    output.writeFieldBegin('Initialized', Thrift.Type.BOOL, 5);
    output.writeBool(this.Initialized);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

ThreeJSUpdate = function(args) {
  this.SceneObjectUpdates = null;
  this.SceneObjectsToRemove = null;
  this.Index = null;
  if (args) {
    if (args.SceneObjectUpdates !== undefined && args.SceneObjectUpdates !== null) {
      this.SceneObjectUpdates = Thrift.copyList(args.SceneObjectUpdates, [ThreeJSSceneObject]);
    }
    if (args.SceneObjectsToRemove !== undefined && args.SceneObjectsToRemove !== null) {
      this.SceneObjectsToRemove = Thrift.copyList(args.SceneObjectsToRemove, [null]);
    }
    if (args.Index !== undefined && args.Index !== null) {
      this.Index = args.Index;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field Index is unset!');
    }
  }
};
ThreeJSUpdate.prototype = {};
ThreeJSUpdate.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.LIST) {
        var _size72 = 0;
        var _rtmp376;
        this.SceneObjectUpdates = [];
        var _etype75 = 0;
        _rtmp376 = input.readListBegin();
        _etype75 = _rtmp376.etype;
        _size72 = _rtmp376.size;
        for (var _i77 = 0; _i77 < _size72; ++_i77)
        {
          var elem78 = null;
          elem78 = new ThreeJSSceneObject();
          elem78.read(input);
          this.SceneObjectUpdates.push(elem78);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.LIST) {
        var _size79 = 0;
        var _rtmp383;
        this.SceneObjectsToRemove = [];
        var _etype82 = 0;
        _rtmp383 = input.readListBegin();
        _etype82 = _rtmp383.etype;
        _size79 = _rtmp383.size;
        for (var _i84 = 0; _i84 < _size79; ++_i84)
        {
          var elem85 = null;
          elem85 = input.readI32().value;
          this.SceneObjectsToRemove.push(elem85);
        }
        input.readListEnd();
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.I32) {
        this.Index = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

ThreeJSUpdate.prototype.write = function(output) {
  output.writeStructBegin('ThreeJSUpdate');
  if (this.SceneObjectUpdates !== null && this.SceneObjectUpdates !== undefined) {
    output.writeFieldBegin('SceneObjectUpdates', Thrift.Type.LIST, 1);
    output.writeListBegin(Thrift.Type.STRUCT, this.SceneObjectUpdates.length);
    for (var iter86 in this.SceneObjectUpdates)
    {
      if (this.SceneObjectUpdates.hasOwnProperty(iter86))
      {
        iter86 = this.SceneObjectUpdates[iter86];
        iter86.write(output);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.SceneObjectsToRemove !== null && this.SceneObjectsToRemove !== undefined) {
    output.writeFieldBegin('SceneObjectsToRemove', Thrift.Type.LIST, 2);
    output.writeListBegin(Thrift.Type.I32, this.SceneObjectsToRemove.length);
    for (var iter87 in this.SceneObjectsToRemove)
    {
      if (this.SceneObjectsToRemove.hasOwnProperty(iter87))
      {
        iter87 = this.SceneObjectsToRemove[iter87];
        output.writeI32(iter87);
      }
    }
    output.writeListEnd();
    output.writeFieldEnd();
  }
  if (this.Index !== null && this.Index !== undefined) {
    output.writeFieldBegin('Index', Thrift.Type.I32, 3);
    output.writeI32(this.Index);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};

BindCallMessage = function(args) {
  this.BindingName = null;
  this.RequestID = null;
  this.ThreeJSUpdate = null;
  this.ThreeJSScene = null;
  this.ArgumentObjectType = null;
  this.ArgumentObjectArg0Name = null;
  this.ArgumentObjectArg0StringValue = null;
  this.ArgumentObjectArg0NumericValue = null;
  this.ArgumentObjectArg1Name = null;
  this.ArgumentObjectArg1StringValue = null;
  this.ArgumentObjectArg1NumericValue = null;
  this.ArgumentObjectArg2Name = null;
  this.ArgumentObjectArg2StringValue = null;
  this.ArgumentObjectArg2NumericValue = null;
  this.ArgumentObjectArg3Name = null;
  this.ArgumentObjectArg3StringValue = null;
  this.ArgumentObjectArg3NumericValue = null;
  this.ArgumentObjectArg4Name = null;
  this.ArgumentObjectArg4StringValue = null;
  this.ArgumentObjectArg4NumericValue = null;
  this.ArgumentObjectArg5Name = null;
  this.ArgumentObjectArg5StringValue = null;
  this.ArgumentObjectArg5NumericValue = null;
  this.ArgumentObjectArg6Name = null;
  this.ArgumentObjectArg6StringValue = null;
  this.ArgumentObjectArg6NumericValue = null;
  this.ArgumentObjectArg7Name = null;
  this.ArgumentObjectArg7StringValue = null;
  this.ArgumentObjectArg7NumericValue = null;
  this.ArgumentObjectArg8Name = null;
  this.ArgumentObjectArg8StringValue = null;
  this.ArgumentObjectArg8NumericValue = null;
  this.ArgumentObjectArg9Name = null;
  this.ArgumentObjectArg9StringValue = null;
  this.ArgumentObjectArg9NumericValue = null;
  if (args) {
    if (args.BindingName !== undefined && args.BindingName !== null) {
      this.BindingName = args.BindingName;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field BindingName is unset!');
    }
    if (args.RequestID !== undefined && args.RequestID !== null) {
      this.RequestID = args.RequestID;
    } else {
      throw new Thrift.TProtocolException(Thrift.TProtocolExceptionType.UNKNOWN, 'Required field RequestID is unset!');
    }
    if (args.ThreeJSUpdate !== undefined && args.ThreeJSUpdate !== null) {
      this.ThreeJSUpdate = new ThreeJSUpdate(args.ThreeJSUpdate);
    }
    if (args.ThreeJSScene !== undefined && args.ThreeJSScene !== null) {
      this.ThreeJSScene = new ThreeJSScene(args.ThreeJSScene);
    }
    if (args.ArgumentObjectType !== undefined && args.ArgumentObjectType !== null) {
      this.ArgumentObjectType = args.ArgumentObjectType;
    }
    if (args.ArgumentObjectArg0Name !== undefined && args.ArgumentObjectArg0Name !== null) {
      this.ArgumentObjectArg0Name = args.ArgumentObjectArg0Name;
    }
    if (args.ArgumentObjectArg0StringValue !== undefined && args.ArgumentObjectArg0StringValue !== null) {
      this.ArgumentObjectArg0StringValue = args.ArgumentObjectArg0StringValue;
    }
    if (args.ArgumentObjectArg0NumericValue !== undefined && args.ArgumentObjectArg0NumericValue !== null) {
      this.ArgumentObjectArg0NumericValue = args.ArgumentObjectArg0NumericValue;
    }
    if (args.ArgumentObjectArg1Name !== undefined && args.ArgumentObjectArg1Name !== null) {
      this.ArgumentObjectArg1Name = args.ArgumentObjectArg1Name;
    }
    if (args.ArgumentObjectArg1StringValue !== undefined && args.ArgumentObjectArg1StringValue !== null) {
      this.ArgumentObjectArg1StringValue = args.ArgumentObjectArg1StringValue;
    }
    if (args.ArgumentObjectArg1NumericValue !== undefined && args.ArgumentObjectArg1NumericValue !== null) {
      this.ArgumentObjectArg1NumericValue = args.ArgumentObjectArg1NumericValue;
    }
    if (args.ArgumentObjectArg2Name !== undefined && args.ArgumentObjectArg2Name !== null) {
      this.ArgumentObjectArg2Name = args.ArgumentObjectArg2Name;
    }
    if (args.ArgumentObjectArg2StringValue !== undefined && args.ArgumentObjectArg2StringValue !== null) {
      this.ArgumentObjectArg2StringValue = args.ArgumentObjectArg2StringValue;
    }
    if (args.ArgumentObjectArg2NumericValue !== undefined && args.ArgumentObjectArg2NumericValue !== null) {
      this.ArgumentObjectArg2NumericValue = args.ArgumentObjectArg2NumericValue;
    }
    if (args.ArgumentObjectArg3Name !== undefined && args.ArgumentObjectArg3Name !== null) {
      this.ArgumentObjectArg3Name = args.ArgumentObjectArg3Name;
    }
    if (args.ArgumentObjectArg3StringValue !== undefined && args.ArgumentObjectArg3StringValue !== null) {
      this.ArgumentObjectArg3StringValue = args.ArgumentObjectArg3StringValue;
    }
    if (args.ArgumentObjectArg3NumericValue !== undefined && args.ArgumentObjectArg3NumericValue !== null) {
      this.ArgumentObjectArg3NumericValue = args.ArgumentObjectArg3NumericValue;
    }
    if (args.ArgumentObjectArg4Name !== undefined && args.ArgumentObjectArg4Name !== null) {
      this.ArgumentObjectArg4Name = args.ArgumentObjectArg4Name;
    }
    if (args.ArgumentObjectArg4StringValue !== undefined && args.ArgumentObjectArg4StringValue !== null) {
      this.ArgumentObjectArg4StringValue = args.ArgumentObjectArg4StringValue;
    }
    if (args.ArgumentObjectArg4NumericValue !== undefined && args.ArgumentObjectArg4NumericValue !== null) {
      this.ArgumentObjectArg4NumericValue = args.ArgumentObjectArg4NumericValue;
    }
    if (args.ArgumentObjectArg5Name !== undefined && args.ArgumentObjectArg5Name !== null) {
      this.ArgumentObjectArg5Name = args.ArgumentObjectArg5Name;
    }
    if (args.ArgumentObjectArg5StringValue !== undefined && args.ArgumentObjectArg5StringValue !== null) {
      this.ArgumentObjectArg5StringValue = args.ArgumentObjectArg5StringValue;
    }
    if (args.ArgumentObjectArg5NumericValue !== undefined && args.ArgumentObjectArg5NumericValue !== null) {
      this.ArgumentObjectArg5NumericValue = args.ArgumentObjectArg5NumericValue;
    }
    if (args.ArgumentObjectArg6Name !== undefined && args.ArgumentObjectArg6Name !== null) {
      this.ArgumentObjectArg6Name = args.ArgumentObjectArg6Name;
    }
    if (args.ArgumentObjectArg6StringValue !== undefined && args.ArgumentObjectArg6StringValue !== null) {
      this.ArgumentObjectArg6StringValue = args.ArgumentObjectArg6StringValue;
    }
    if (args.ArgumentObjectArg6NumericValue !== undefined && args.ArgumentObjectArg6NumericValue !== null) {
      this.ArgumentObjectArg6NumericValue = args.ArgumentObjectArg6NumericValue;
    }
    if (args.ArgumentObjectArg7Name !== undefined && args.ArgumentObjectArg7Name !== null) {
      this.ArgumentObjectArg7Name = args.ArgumentObjectArg7Name;
    }
    if (args.ArgumentObjectArg7StringValue !== undefined && args.ArgumentObjectArg7StringValue !== null) {
      this.ArgumentObjectArg7StringValue = args.ArgumentObjectArg7StringValue;
    }
    if (args.ArgumentObjectArg7NumericValue !== undefined && args.ArgumentObjectArg7NumericValue !== null) {
      this.ArgumentObjectArg7NumericValue = args.ArgumentObjectArg7NumericValue;
    }
    if (args.ArgumentObjectArg8Name !== undefined && args.ArgumentObjectArg8Name !== null) {
      this.ArgumentObjectArg8Name = args.ArgumentObjectArg8Name;
    }
    if (args.ArgumentObjectArg8StringValue !== undefined && args.ArgumentObjectArg8StringValue !== null) {
      this.ArgumentObjectArg8StringValue = args.ArgumentObjectArg8StringValue;
    }
    if (args.ArgumentObjectArg8NumericValue !== undefined && args.ArgumentObjectArg8NumericValue !== null) {
      this.ArgumentObjectArg8NumericValue = args.ArgumentObjectArg8NumericValue;
    }
    if (args.ArgumentObjectArg9Name !== undefined && args.ArgumentObjectArg9Name !== null) {
      this.ArgumentObjectArg9Name = args.ArgumentObjectArg9Name;
    }
    if (args.ArgumentObjectArg9StringValue !== undefined && args.ArgumentObjectArg9StringValue !== null) {
      this.ArgumentObjectArg9StringValue = args.ArgumentObjectArg9StringValue;
    }
    if (args.ArgumentObjectArg9NumericValue !== undefined && args.ArgumentObjectArg9NumericValue !== null) {
      this.ArgumentObjectArg9NumericValue = args.ArgumentObjectArg9NumericValue;
    }
  }
};
BindCallMessage.prototype = {};
BindCallMessage.prototype.read = function(input) {
  input.readStructBegin();
  while (true)
  {
    var ret = input.readFieldBegin();
    var fname = ret.fname;
    var ftype = ret.ftype;
    var fid = ret.fid;
    if (ftype == Thrift.Type.STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
      if (ftype == Thrift.Type.STRING) {
        this.BindingName = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 2:
      if (ftype == Thrift.Type.I32) {
        this.RequestID = input.readI32().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 3:
      if (ftype == Thrift.Type.STRUCT) {
        this.ThreeJSUpdate = new ThreeJSUpdate();
        this.ThreeJSUpdate.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 4:
      if (ftype == Thrift.Type.STRUCT) {
        this.ThreeJSScene = new ThreeJSScene();
        this.ThreeJSScene.read(input);
      } else {
        input.skip(ftype);
      }
      break;
      case 5:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectType = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 6:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg0Name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 7:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg0StringValue = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 8:
      if (ftype == Thrift.Type.DOUBLE) {
        this.ArgumentObjectArg0NumericValue = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 9:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg1Name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 10:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg1StringValue = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 11:
      if (ftype == Thrift.Type.DOUBLE) {
        this.ArgumentObjectArg1NumericValue = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 12:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg2Name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 13:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg2StringValue = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 14:
      if (ftype == Thrift.Type.DOUBLE) {
        this.ArgumentObjectArg2NumericValue = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 15:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg3Name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 16:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg3StringValue = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 17:
      if (ftype == Thrift.Type.DOUBLE) {
        this.ArgumentObjectArg3NumericValue = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 18:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg4Name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 19:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg4StringValue = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 20:
      if (ftype == Thrift.Type.DOUBLE) {
        this.ArgumentObjectArg4NumericValue = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 21:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg5Name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 22:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg5StringValue = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 23:
      if (ftype == Thrift.Type.DOUBLE) {
        this.ArgumentObjectArg5NumericValue = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 24:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg6Name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 25:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg6StringValue = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 26:
      if (ftype == Thrift.Type.DOUBLE) {
        this.ArgumentObjectArg6NumericValue = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 27:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg7Name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 28:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg7StringValue = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 29:
      if (ftype == Thrift.Type.DOUBLE) {
        this.ArgumentObjectArg7NumericValue = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 30:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg8Name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 31:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg8StringValue = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 32:
      if (ftype == Thrift.Type.DOUBLE) {
        this.ArgumentObjectArg8NumericValue = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 33:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg9Name = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 34:
      if (ftype == Thrift.Type.STRING) {
        this.ArgumentObjectArg9StringValue = input.readString().value;
      } else {
        input.skip(ftype);
      }
      break;
      case 35:
      if (ftype == Thrift.Type.DOUBLE) {
        this.ArgumentObjectArg9NumericValue = input.readDouble().value;
      } else {
        input.skip(ftype);
      }
      break;
      default:
        input.skip(ftype);
    }
    input.readFieldEnd();
  }
  input.readStructEnd();
  return;
};

BindCallMessage.prototype.write = function(output) {
  output.writeStructBegin('BindCallMessage');
  if (this.BindingName !== null && this.BindingName !== undefined) {
    output.writeFieldBegin('BindingName', Thrift.Type.STRING, 1);
    output.writeString(this.BindingName);
    output.writeFieldEnd();
  }
  if (this.RequestID !== null && this.RequestID !== undefined) {
    output.writeFieldBegin('RequestID', Thrift.Type.I32, 2);
    output.writeI32(this.RequestID);
    output.writeFieldEnd();
  }
  if (this.ThreeJSUpdate !== null && this.ThreeJSUpdate !== undefined) {
    output.writeFieldBegin('ThreeJSUpdate', Thrift.Type.STRUCT, 3);
    this.ThreeJSUpdate.write(output);
    output.writeFieldEnd();
  }
  if (this.ThreeJSScene !== null && this.ThreeJSScene !== undefined) {
    output.writeFieldBegin('ThreeJSScene', Thrift.Type.STRUCT, 4);
    this.ThreeJSScene.write(output);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectType !== null && this.ArgumentObjectType !== undefined) {
    output.writeFieldBegin('ArgumentObjectType', Thrift.Type.STRING, 5);
    output.writeString(this.ArgumentObjectType);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg0Name !== null && this.ArgumentObjectArg0Name !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg0Name', Thrift.Type.STRING, 6);
    output.writeString(this.ArgumentObjectArg0Name);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg0StringValue !== null && this.ArgumentObjectArg0StringValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg0StringValue', Thrift.Type.STRING, 7);
    output.writeString(this.ArgumentObjectArg0StringValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg0NumericValue !== null && this.ArgumentObjectArg0NumericValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg0NumericValue', Thrift.Type.DOUBLE, 8);
    output.writeDouble(this.ArgumentObjectArg0NumericValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg1Name !== null && this.ArgumentObjectArg1Name !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg1Name', Thrift.Type.STRING, 9);
    output.writeString(this.ArgumentObjectArg1Name);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg1StringValue !== null && this.ArgumentObjectArg1StringValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg1StringValue', Thrift.Type.STRING, 10);
    output.writeString(this.ArgumentObjectArg1StringValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg1NumericValue !== null && this.ArgumentObjectArg1NumericValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg1NumericValue', Thrift.Type.DOUBLE, 11);
    output.writeDouble(this.ArgumentObjectArg1NumericValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg2Name !== null && this.ArgumentObjectArg2Name !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg2Name', Thrift.Type.STRING, 12);
    output.writeString(this.ArgumentObjectArg2Name);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg2StringValue !== null && this.ArgumentObjectArg2StringValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg2StringValue', Thrift.Type.STRING, 13);
    output.writeString(this.ArgumentObjectArg2StringValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg2NumericValue !== null && this.ArgumentObjectArg2NumericValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg2NumericValue', Thrift.Type.DOUBLE, 14);
    output.writeDouble(this.ArgumentObjectArg2NumericValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg3Name !== null && this.ArgumentObjectArg3Name !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg3Name', Thrift.Type.STRING, 15);
    output.writeString(this.ArgumentObjectArg3Name);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg3StringValue !== null && this.ArgumentObjectArg3StringValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg3StringValue', Thrift.Type.STRING, 16);
    output.writeString(this.ArgumentObjectArg3StringValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg3NumericValue !== null && this.ArgumentObjectArg3NumericValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg3NumericValue', Thrift.Type.DOUBLE, 17);
    output.writeDouble(this.ArgumentObjectArg3NumericValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg4Name !== null && this.ArgumentObjectArg4Name !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg4Name', Thrift.Type.STRING, 18);
    output.writeString(this.ArgumentObjectArg4Name);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg4StringValue !== null && this.ArgumentObjectArg4StringValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg4StringValue', Thrift.Type.STRING, 19);
    output.writeString(this.ArgumentObjectArg4StringValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg4NumericValue !== null && this.ArgumentObjectArg4NumericValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg4NumericValue', Thrift.Type.DOUBLE, 20);
    output.writeDouble(this.ArgumentObjectArg4NumericValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg5Name !== null && this.ArgumentObjectArg5Name !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg5Name', Thrift.Type.STRING, 21);
    output.writeString(this.ArgumentObjectArg5Name);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg5StringValue !== null && this.ArgumentObjectArg5StringValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg5StringValue', Thrift.Type.STRING, 22);
    output.writeString(this.ArgumentObjectArg5StringValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg5NumericValue !== null && this.ArgumentObjectArg5NumericValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg5NumericValue', Thrift.Type.DOUBLE, 23);
    output.writeDouble(this.ArgumentObjectArg5NumericValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg6Name !== null && this.ArgumentObjectArg6Name !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg6Name', Thrift.Type.STRING, 24);
    output.writeString(this.ArgumentObjectArg6Name);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg6StringValue !== null && this.ArgumentObjectArg6StringValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg6StringValue', Thrift.Type.STRING, 25);
    output.writeString(this.ArgumentObjectArg6StringValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg6NumericValue !== null && this.ArgumentObjectArg6NumericValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg6NumericValue', Thrift.Type.DOUBLE, 26);
    output.writeDouble(this.ArgumentObjectArg6NumericValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg7Name !== null && this.ArgumentObjectArg7Name !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg7Name', Thrift.Type.STRING, 27);
    output.writeString(this.ArgumentObjectArg7Name);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg7StringValue !== null && this.ArgumentObjectArg7StringValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg7StringValue', Thrift.Type.STRING, 28);
    output.writeString(this.ArgumentObjectArg7StringValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg7NumericValue !== null && this.ArgumentObjectArg7NumericValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg7NumericValue', Thrift.Type.DOUBLE, 29);
    output.writeDouble(this.ArgumentObjectArg7NumericValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg8Name !== null && this.ArgumentObjectArg8Name !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg8Name', Thrift.Type.STRING, 30);
    output.writeString(this.ArgumentObjectArg8Name);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg8StringValue !== null && this.ArgumentObjectArg8StringValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg8StringValue', Thrift.Type.STRING, 31);
    output.writeString(this.ArgumentObjectArg8StringValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg8NumericValue !== null && this.ArgumentObjectArg8NumericValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg8NumericValue', Thrift.Type.DOUBLE, 32);
    output.writeDouble(this.ArgumentObjectArg8NumericValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg9Name !== null && this.ArgumentObjectArg9Name !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg9Name', Thrift.Type.STRING, 33);
    output.writeString(this.ArgumentObjectArg9Name);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg9StringValue !== null && this.ArgumentObjectArg9StringValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg9StringValue', Thrift.Type.STRING, 34);
    output.writeString(this.ArgumentObjectArg9StringValue);
    output.writeFieldEnd();
  }
  if (this.ArgumentObjectArg9NumericValue !== null && this.ArgumentObjectArg9NumericValue !== undefined) {
    output.writeFieldBegin('ArgumentObjectArg9NumericValue', Thrift.Type.DOUBLE, 35);
    output.writeDouble(this.ArgumentObjectArg9NumericValue);
    output.writeFieldEnd();
  }
  output.writeFieldStop();
  output.writeStructEnd();
  return;
};


window.Alt.PositronHost = "account.altvr.com";
window.Alt.PositronProtocol = "https";
window.Alt.PositronPort = 443;
window.Alt.UseAuthToken = true; // AUTHMIGRATE remove when rails endpoints are updated to use users/reauth template

window.engine.call("GetPositronHost").then(function(host) {
	Alt.PositronHost = host;
});

window.engine.call("GetPositronProtocol").then(function(protocol) {
	Alt.PositronProtocol = protocol;
});

window.engine.call("GetPositronPort").then(function(port) {
	Alt.PositronPort = port;
});

window.Alt.Log = function(m) {
	console.log(m);
};

// These overrides are required- these webkitAudioContext methods cause the main Unity
// thread to stop responding (with coherent in-client audio streaming enabled)
// Probably _all_ methods that return AudioNodes will do this, but these are the only
// ones currently in use.
(function () {
	var audioContext = window.webkitAudioContext || window.AudioContext;
	if(!audioContext) {
		console.warn("Altspace: Browser doesn't have an AudioContext API. Could not override prototype.");
		return;
	}
	audioContext.prototype.createMediaElementSource = function(myMediaElement) {
		console.error("createMediaElementSource is disabled in AltspaceVR.");
		return null;
	}
	audioContext.prototype.createAnalyser = function() {
		console.error("createAnalyser is disabled in AltspaceVR.");
		return null;
	}
})();

// Override window.open. Used to prevent pages from creating a pop-up,
// which Altspace's browser can't handle currently.
window.nativeOpen = window.open;
window.nativeOpen.bind(window);
window.open = function(url, name, features, replace){
	return window.nativeOpen(url, '_self', features, replace);
};

// Stub out alert, confirm, and prompt
window.alert = function(alert) { };
window.confirm = function(confirm) { return true; };
window.prompt = function(message, defaultValue) { return defaultValue; };

if (!window.chrome) {
	window.chrome = {};
}

// Protect console
Object.defineProperty(window, 'console', {value: window.console, configurable : false});

// Called by YouTube API on YouTube.com.
window.onYouTubePlayerReady = function(player) {
	window.Alt.CapturedYouTubePlayer = player;
};

if (typeof(_) != "undefined") {
	window.Alt._ = _.noConflict();
}

// Set up overrides to requestAnimationFrame to throttle its framerate.
// Unthrottled in coherent it seems to run at 1000+ FPS, still unclear why.
// Unpatched version works fine on GearVR so leave it as is.
if (navigator.userAgent.indexOf('Mobile') === -1) {
	((function(){
		var id = 0;
		var renderQueue = [];
		var fps = 60;
		var frameDelay = 1000 / fps;
		var last = 0;

		var processRenderQueue = function(now) {
			var tmp = renderQueue.slice(0);
			renderQueue.length = 0;
			for (var i = 0; i < tmp.length; i++) {
				try {
					if (!tmp[i].canceled) {
						tmp[i].callback.call(null, now);
					}
				} catch (e) {
					setTimeout(function() { throw e }, 0);
				}
			}
		};

		window.requestAnimationFrame = function(callback) {
			if (renderQueue.length === 0) {
				var now = window.performance.now(),
					next = Math.max(0, frameDelay - (now - last));
				last = next + now;
				setTimeout(function () { processRenderQueue(last); }, Math.round(next));
			}
			renderQueue.push({
				id: ++id,
				callback: callback,
				canceled: false
			});
			return id;
		};

		window.cancelAnimationFrame = function(id) {
			for (var i = 0; i < renderQueue.length; i++) {
				if (renderQueue[i].id === id) {
					renderQueue[i].canceled = true;
				}
			}
		};
	})(window.requestAnimationFrame, window.cancelAnimationFrame));
}

(function () {
		var iframeWhitelist = ['codepen.io', 's.codepen.io', 'localhost', 'rawgit.com', 'cdn.rawgit.com'];

		window.Alt.shouldSupportIFrames = iframeWhitelist.indexOf(location.hostname) >= 0;

		var inIFrame = self !== top;

		if (window.Alt.shouldSupportIFrames && inIFrame) {
				//Since ExecuteScript only works on the topmost document, we 'inject' loaded.min.js manually if we are in an iframe
				window.addEventListener('DOMContentLoaded', function () {
						[
								(/Mobile/.test(navigator.userAgent) ? 'http://altvr.localhost/' : 'coui://') + 'uiresources/Altspace/loaded.min.js'
						].forEach(function (src) {
								var script = document.createElement('script');
								script.src = src;
								script.async = false;
								document.head.appendChild(script);
						});
				});
		}
}());

(function () {
	var isMobile = navigator.userAgent.indexOf('Mobile') !== -1;

	// Ugly hack to fix CSS on slides.com. A CSS rule on slides.com uses a calc() expression with vh units, which does
	// not work in the version of WebKit used by our current version of Coherent.
	// This fix simply polyfills the calc() expression in javascript.
	// TODO Remove this when we upgrate Coherent (https://altspacevr.atlassian.net/browse/UNC-54)
	if (/slides\.com$/.test(location.host)) {
		setInterval(function () {
			var slides = document.querySelector('html.decks.show .marquee .reveal-frame');
			if (slides) {
				var desiredHeight = (window.innerHeight - 90) + 'px';
				if (slides.style.height !== desiredHeight) {
					slides.style.height = desiredHeight;
				}
			}
		}, 500);
	}

	// In order to support 360 videos from YouTube, we inject some JS into the embed iframe that listens for a
	// postMessage and then removes various UI, leaving the raw equirectangular 360 video.
	// We don't do this on mobile since AndroidWebView doesn't inject JS into iframes.
	if (/youtube.com\/embed\//.test(location.href) && !isMobile) {
		window.addEventListener('message', function (event) {
			if (!event.data.isAltspaceYoutubeMessage || !event.data.remove360UI) { return; }
			// scale the video so that it fills the browser window
			var video = document.querySelector('video')
			if (video) {
				var frameHeight = parseFloat(video.style.height);
				var frameWidth = parseFloat(video.style.width);
				var videoHeight = video.videoHeight;
				var videoWidth = video.videoWidth;
				video.style.transform = (
					'scaleY(' + (window.innerHeight / frameHeight) + ') ');
				if (videoWidth / videoHeight !== frameWidth / frameHeight) {
					video.style.transform += (
						'scaleX(' + frameWidth / frameHeight * window.innerHeight / window.innerWidth + ')');
				}
			}

			// hide the 360 webgl renderer
			var webgls = Array.prototype.slice.call(document.querySelectorAll('.webgl'));
			if (webgls.length) {
				webgls.forEach(function (webgl) {
					webgl.style.display = 'none';
				});
				var canvases = Array.prototype.slice.call(document.querySelectorAll('.webgl canvas'));
				canvases.forEach(function (canvas) {
					// helps with performance if there's no canvas surface area to draw on
					canvas.width = canvas.height = 0;
				});
			}

			// hide the 360 pan controls
			var webglControls = Array.prototype.slice.call(document.querySelectorAll('.ytp-webgl-spherical-control'));
			if (webglControls) {
				webglControls.forEach(function (webglControl) {
					webglControl.style.display = 'none';
				});
			}
		});
	}

	// We don't need to do this on Mobile since the Chrome WebView has up-to-date DOM APIs.
	if (location.href.indexOf('player.twitch.tv/?channel=') !== -1 && !isMobile) {
		// Twitch tries to use shadowRoot, which does not have a property descriptor in our version of Coherent
		// so we fake its getter here with a noop.
		Object.defineProperty(window.Element.prototype, 'shadowRoot', {get: function () {}});
	}
}());

/// <reference path="../deps/EventDispatcher.js" />
/* global EventDispatcher, THREE */
// New SDK APIs
(function () {
	var altspace = window.altspace;
	var internal = altspace._internal;
	// TODO: Ideally this gets deleted from here or never is placed on window in the first place
	internal.couiEngine = window.engine;

	// Wrapper around coherent's engine.call.
	// Eventually this could take authentication info, or utilize other channels like a local websocket.
	// Catch on Unity side via WebViewFacade.BindCall(name, ...)
	internal.callClientFunction = function (name, args, config) {
		var couiArgs = {};

		if (args !== undefined) {
			if (!config || !config.hasOwnProperty('argsType')) {
				console.warn('To use COUI engine.call with arguments, argsType must be defined in the config');
				return null;
			}

			// This must be the first property on the object. COUI weirdness
			couiArgs.__Type = config.argsType;
			for (var k in args) if (args.hasOwnProperty(k)) couiArgs[k] = args[k];
		}

		return internal.couiEngine.call(name, couiArgs);
	};

	// Wrapper around coherent's engine.triggerEvent.
	// Eventually this could take authentication info, or utilize other channels like a local websocket.
	// Catch on Unity side via WebViewFacade.BindCall(name, ...)
	internal.callClientAction = function (name, args, config) {
		var couiArgs = {};

		if (args !== undefined) {
			if (!config || !config.hasOwnProperty('argsType')) {
				console.warn('To use COUI engine.call with arguments, argsType must be defined in the config');
				return null;
			}

			// This must be the first property on the object. COUI weirdness
			couiArgs.__Type = config.argsType;
			for (var k in args) if (args.hasOwnProperty(k)) couiArgs[k] = args[k];
		}

		return internal.couiEngine.trigger(name, couiArgs);
	};

	internal.onClientEvent = function (name, callback, context) {
		return internal.couiEngine.on(name, callback, context);
	};

	function executeFunction(func, args) {
		var target = null;
		var f = window;

		var splitFunc = func.split('.');
		for (var i = 0, max = splitFunc.length; i < max; i++) {
			var name = splitFunc[i];
			target = f;
			f = f[name];
			if (!f) {
				break;
			}
		}

		if (target && f) {
			return f.call(target, args);
		}
		return false;
	}

	function chainWhenFunctionExists(funcPath, args) {
		var spinPromise = engine.createDeferred();
		var interval;
		function spin() {
			var funcPromise = executeFunction(funcPath, args);
			// This will not fire if the executedFunction does not return a promise
			if (funcPromise) {
				clearInterval(interval);
				interval = null;
				funcPromise.then(function () {
					spinPromise.resolve.apply(spinPromise, arguments);
				}, function () {
					spinPromise.reject.apply(spinPromise, arguments);
				});
			}
		}
		interval = setInterval(spin, 10);
		setTimeout(spin, 0);// Fire immediately but don't unleash Zalgo
		return spinPromise;
	}

	// iFrame Events //

	var iframes = document.getElementsByTagName('iframe');// This is a live NodeList

	internal.forwardEventToChildIFrames = function (eventName, eventArgs) {
		if (!internal.Alt.shouldSupportIFrames) return;

		var event = { isAltspaceIFrameEvent: true, eventName: eventName, eventArgs: eventArgs };

		for (var i = 0, max = iframes.length; i < max; i++) {
			var iframe = iframes[i];
			iframe.contentWindow.postMessage(event, '*');
		}
	};

	window.addEventListener('message', function (event) {
		// Pretty bad. No origin checks. Maybe have it come from a proxy iframe or something?
		if (!event.data.isAltspaceIFrameEvent) return;

		var nameAndArgs = event.data.eventArgs;
		nameAndArgs.unshift(event.data.eventName);

		window.altspace._internal.couiEngine.trigger.apply(window.altspace._internal.couiEngine, nameAndArgs);
	});

	// Visibility
	(function () {
		var _hidden = false;

		altspace._internal.onClientEvent('VisibilityChanged', function (args) {
			if (_hidden !== args.Hidden) {
				_hidden = args.Hidden;
				document.dispatchEvent(new Event('visibilitychange'));
			}
		});

		Object.defineProperty(document, 'hidden', {
			configurable: false,
			get: function () { return _hidden; }
		});

		Object.defineProperty(document, 'visibilityState', {
			configurable: false,
			get: function () { return _hidden ? 'hidden' : 'visible'; }
		});
	}());


	// User //
	altspace.getUser = function () {
		return chainWhenFunctionExists('altspace._internal.Alt.Users.getLocalUser');
	};

	// Spaces //
	altspace.getSpace = function () {
		return internal.callClientFunction('GetSpace').then(function (args) {
			return {
				sid: args.SID,
				name: args.Name,
				templateSid: args.TemplateSID,
			};
		});
	};

	// Events //

	EventDispatcher.prototype.apply(altspace);

	// Three.js

	(function () {
		var currentScene;
		var renderer;

		altspace.getThreeJSRenderer = function (options) {
			options = options || {};
			if (!window.THREE) {
				console.warn('The AltspaceVR three.js renderer cannot be used without a ' +
					'valid version of three.js loaded to window.THREE');
				return null;
			}
			if (parseInt(window.THREE.REVISION, 10) < 69) {
				console.warn('The AltspaceVR three.js renderer cannot be used with a ' +
					'revision of three.js less than 69');
				return null;
			}
			if (renderer) return renderer;

			if (options.profile) {
				altspace._internal.ScratchThriftBuffer.profile = options.profile;
			}
			if (options.initialSerializationBufferSize) {
				if (
					isNaN(options.initialSerializationBufferSize) ||
					options.initialSerializationBufferSize <= 1024 ||
					options.initialSerializationBufferSize >= 1024 * 1024 * 64
				) {
					console.warn('initialSerializationBufferSize must be between 1,024 and 67,108,864.');
					return null;
				}
				altspace._internal.ScratchThriftBuffer.grow(options.initialSerializationBufferSize);
			}
			renderer = new altspace._internal.AltRenderer(options);

			internal.callClientFunction('ThreeJSApiUsed');
			return renderer;
		};

		internal.setThreeJSScene = function (scene) {
			currentScene = scene;
		};

		internal.getThreeJSScene = function () {
			return currentScene;
		};
	})();

	altspace.setHighPerfMode = function (enabled) {
		internal.callClientFunction('SetHighPerfMode', { Enabled: enabled }, { argsType: 'SetHighPerfModeOptions' });
	};

	altspace.setConfigBasedUserAgent = function (enabled) {
		internal.callClientFunction(
			'SetConfigBasedUserAgent', { Enabled: enabled }, { argsType: 'SetConfigBasedUserAgentOptions' });
	};

	Object.defineProperty(altspace, 'inClient', {
		configurable: false,
		enumerable: true,
		value: true,
		writable: false
	});

	Object.defineProperty(altspace, 'utilities', {
		configurable: false,
		enumerable: true,
		value: {},
		writable: false
	});

	// added for aframe component stubs
	Object.defineProperty(altspace, 'components', {
		configurable: false,
		enumerable: true,
		value: {},
		writable: false
	});
})();

(function() {

	var cachedObject3DTargets = {};
	var internal = altspace._internal;

	function getObjectByProperty(name, value) {
		if (this[name] === value) return this;

		for (var i = 0, l = this.children.length; i < l; i++) {
			var child = this.children[i];
			var object = getObjectByProperty.call(child, name, value);

			if (object !== undefined) {
				return object;
			}
		}

		return undefined;
	}

	internal.getObject3DById = function (targetMeshId) {
		var target = cachedObject3DTargets[targetMeshId];
		var currentScene = internal.getThreeJSScene();

		if (!target) {
			var findTarget = currentScene.getObjectByProperty || getObjectByProperty;
			target = findTarget.call(currentScene, 'id', targetMeshId);
			cachedObject3DTargets[targetMeshId] = target;
		}
		return target;
	}

	internal.dispatchObject3DEvent = function(event) {
		var shouldStopPropagation;
		var shouldStopPropagationImmediately;

		if (event.bubbles) {
			event.currentTarget = this;

			event.stopPropagation = function () {
				shouldStopPropagation = true;
			};

			event.stopImmediatePropagation = function () {
				shouldStopPropagationImmediately = true;
			};
		}

		if (!event.target) {
			event.target = this;
		}

		if (this._listeners) {
			var listeners = this._listeners;
			var listenerArray = listeners[event.type];

			if (listenerArray) {
				var array = [];
				var length = listenerArray.length;

				var i;
				for (i = 0; i < length; i++) {
					array[i] = listenerArray[i];
				}

				for (i = 0; i < length; i++) {
					array[i].call(this, event);

					if (shouldStopPropagationImmediately) return;
				}
			}
		}


		if (event.bubbles && this.parent && this.parent.dispatchEvent && !shouldStopPropagation) {
			internal.dispatchObject3DEvent.call(this.parent, event);
		}
	}
})();

(function () {
	var internal = altspace._internal;
	internal.enclosure = {// TODO: This should be top level when back / forward bug is fixed
		innerWidth: 0,
		innerHeight: 0,
		innerDepth: 0,
		pixelsPerMeter: 0,
		hasFocus: false,
		fullspace: false,
		requestFullspace: requestFullspace,
		exitFullspace: exitFullspace
	};

	EventDispatcher.prototype.apply(internal.enclosure);

	function requestFullspace() {
		return new Promise(function (resolve, reject) {
			internal.callClientFunction('RequestFullspace').then(function (succeeded) {
				if (succeeded) {
					internal.enclosure.fullspace = true;
					resolve();
				}
				else {
					reject();
				}
			});
		});
	}


	function exitFullspace() {
		return internal.callClientFunction('ExitFullspace').then(function () {
			internal.enclosure.fullspace = false;
		});
	}


	internal.onClientEvent('FullspaceChanged', function (args) {
		internal.forwardEventToChildIFrames('FullspaceChanged', [args]);
		internal.enclosure.fullspace = args.IsFullspace;
		internal.enclosure.pixelsPerMeter = args.PixelsPerMeter;
		internal.enclosure.dispatchEvent({type: 'fullspacechange'});
	});

	internal.onClientEvent('DimensionsChanged', function (args) {
		internal.forwardEventToChildIFrames('DimensionsChanged', [args]);
		internal.enclosure.innerWidth = args.Width;
		internal.enclosure.innerHeight = args.Height;
		internal.enclosure.innerDepth = args.Depth;
	});
	internal.onClientEvent('PixelsPerMeterChanged', function (args) {
		internal.forwardEventToChildIFrames('PixelsPerMeterChanged', [args]);
		internal.enclosure.pixelsPerMeter = args.PixelsPerMeter;
	});

	window.addEventListener('focus', function () {
		internal.enclosure.hasFocus = true;
	});

	window.addEventListener('blur', function () {
		internal.enclosure.hasFocus = false;
	});

	altspace.getEnclosure = function () {
		return internal.callClientFunction('GetEnclosure').then(function (args) {
			internal.enclosure.innerWidth = args.Width;
			internal.enclosure.innerHeight = args.Height;
			internal.enclosure.innerDepth = args.Depth;
			internal.enclosure.pixelsPerMeter = args.PixelsPerMeter;
			internal.enclosure.hasFocus = args.HasFocus;
			internal.enclosure.fullspace = args.IsFullspace;
			return internal.enclosure;
		});
	};
}());

(function () {
	var internal = altspace._internal;
	var shouldSendTouchpadUpdates = false;


	function hasTouchpadListeners() {
		function hasListeners(type) {
			return altspace._listeners[type] && altspace._listeners[type].length;
		}
		return (
			hasListeners('touchpadup') || hasListeners('touchpaddown') ||
			hasListeners('touchpadmove') || hasListeners('touchpadgesture'));
	}
	function isTouchpadUpdateEvent(type) {
		return (
			type === 'touchpadup' || type === 'touchpaddown' ||
			type === 'touchpadmove' || type === 'touchpadgesture');
	}
	function onListenerAdded(event) {
		if (isTouchpadUpdateEvent(event.listenerType) && !shouldSendTouchpadUpdates) {
			internal.callClientFunction('EnableTouchpadUpdates');
			shouldSendTouchpadUpdates = true;
		}
	}
	function onListenerRemoved(event) {
		if (isTouchpadUpdateEvent(event.listenerType) && !hasTouchpadListeners()) {
			internal.callClientFunction('DisableTouchpadUpdates');
			shouldSendTouchpadUpdates = false;
		}
	}
	altspace.addEventListener('listeneradded', onListenerAdded);
	altspace.addEventListener('listenerremoved', onListenerRemoved);

	var lastX;
	var lastY;
	internal.onClientEvent('TouchpadUpdated', function () {
		var args = arguments;
		internal.forwardEventToChildIFrames('TouchpadUpdated', args);

		var x = args[0];
		var y = args[1];
		var up = args[2];
		var down = args[3];

		if (up) {
			altspace.dispatchEvent({
				type: 'touchpadup',
				displacementX: x,
				displacementY: y
			});
		}
		if (down) {
			altspace.dispatchEvent({
				type: 'touchpaddown',
				displacementX: 0,
				displacementY: 0
			});
		}
		var displacementChanged = x !== lastX || y !== lastY;
		var hasDisplacement = !(x === 0 && y === 0);
		if (hasDisplacement && displacementChanged) {
			altspace.dispatchEvent({
				type: 'touchpadmove',
				displacementX: x,
				displacementY: y
			});
		}

		lastX = x;
		lastY = y;
	});


	internal.onClientEvent('TouchpadGesture', function () {
		var args = arguments;
		internal.forwardEventToChildIFrames('TouchpadGesture', args);

		altspace.dispatchEvent({
			type: 'touchpadgesture',
			gesture: TouchpadGesture[args[0]]
		});
	});
}());

(function () {
	function filterInternalInfo(debugInfoObj) {
		for (var key in debugInfoObj) {
			if (debugInfoObj.hasOwnProperty(key)) {
				if (key[0] === '_') {
					delete debugInfoObj[key];
				}
				if (typeof debugInfoObj[key] === 'object') {
					filterInternalInfo(debugInfoObj[key]);
				}
			}
		}
	}

	altspace.getThreeJSDebugInfo = function () {
		return altspace._internal.callClientFunction('GetThreeJSDebugInfo').then(
			function (debugInfo) {
				debugInfo.forEach(filterInternalInfo);
				return debugInfo;
			}
		);
	};
}());

/* global THREE */
(function () {
	var internal = altspace._internal;
	// TODO: optimize cursor events by ensuring that event listeners exist before turning on the firehose

	internal.onClientEvent('ThreeJSCursorEvent', function () {
		var args = Array.prototype.slice.call(arguments);
		internal.forwardEventToChildIFrames('ThreeJSCursorEvent', args);

		var currentScene = internal.getThreeJSScene();
		if (!currentScene) return;
		if (!window.THREE) return;

		var eventType = args[0];
		var targetMeshId = args[1];
		var hasTargetMesh = args[2];
		var cursorHitPosition = new THREE.Vector3(args[3], args[4], args[5]);// TODO reuse
		var ray = new THREE.Ray(new THREE.Vector3(args[6], args[7], args[8]),
		new THREE.Vector3(args[9], args[10], args[11]));

		var target = currentScene;

		if (hasTargetMesh) {
			target = internal.getObject3DById(targetMeshId) || target;
		}

		var event = { type: eventType, ray: ray, point: cursorHitPosition, bubbles: true };

		internal.dispatchObject3DEvent.call(target, event);
	});
}());

/* global THREE */
(function () {
	var internal = altspace._internal;
	var gamepads = [];
	var requestedGamepads = false;

	altspace.getGamepads = function () {
		if (!requestedGamepads) {
			internal.callClientFunction('StartUpdatingGamepad');
			requestedGamepads = true;
		}
		return gamepads;
	};

	var GamepadButton = function () {
		this.pressed = false;
		this.touched = false;
		this.nearlyTouched = false;
		this.value = 0;
	};
	Object.defineProperties(GamepadButton.prototype, {
		nearTouch: {
			get: function () {
				console.warn('GamepadButton.nearTouch is now .nearlyTouched');
				return this.nearlyTouched;
			}
		}
	});

	var Gamepad = function (mapping) {
		var numButtons = 0;
		var numAxes = 0;

		if (mapping === 'standard') {
			numButtons = 16;
			numAxes = 4;
		} else if (mapping === 'steamvr') {
			numButtons = 7;
			numAxes = 2;
		} else if (mapping === 'touch') {
			numButtons = 6;
			numAxes = 2;
		}

		if (mapping === 'steamvr' || mapping === 'touch') {
			this.position = { x: 0, y: 0, z: 0 };
			this.rotation = { x: 0, y: 0, z: 0, w: 0 };
			this.pose = {
				position: [],
				orientation: []
			};
		}

		this.mapping = mapping; // 0
		this.id = 0;						// 1
		this.index = 0;				 // 2
		this.timestamp = 0;		 // 3
		this.connected = false; // 4

		this.axes = [];
		this.buttons = [];

		var i;
		for (i = 0; i < numAxes; i++) {
			this.axes[i] = 0;
		}

		for (i = 0; i < numButtons; i++) {
			this.buttons[i] = new GamepadButton();
		}
	};
	Gamepad.prototype.preventDefault = function (axes, buttons) {
		// Convert bool array to string "mask" of zeros and ones,
		// since passing arrays or lists through coui isn't working.
		var a = '';
		var b = '';
		var i;
		for (i = 0; i < axes.length; i++) a += axes[i] ? '1' : '0';
		for (i = 0; i < buttons.length; i++) b += buttons[i] ? '1' : '0';
		internal.callClientFunction('BlockGamepad', {
			Index: this.index,
			Axes: a,
			Buttons: b
		}, { argsType: 'BlockGamepadType' });
	};

	var poseQuaternion;
	internal.onClientEvent('GamepadUpdated', function () {
		var args = Array.prototype.slice.call(arguments); // do we need to do this?
		internal.forwardEventToChildIFrames('GamepadUpdated', args);

		var o = 0;

		var mapping = args[o++];
		var id = args[o++];
		var index = args[o++];
		var timestamp = args[o++];
		var connected = args[o++];


		if (!gamepads[index]) {
			gamepads[index] = new Gamepad(mapping);
		}

		var gamepad = gamepads[index];
		gamepad.id = id;
		gamepad.index = index;
		gamepad.timestamp = timestamp;
		gamepad.connected = connected;

		var i;
		var numAxes = gamepad.axes.length;
		var numButtons = gamepad.buttons.length;
		for (i = 0; i < numAxes; i++) {
			gamepad.axes[i] = args[o++];
		}
		for (i = 0; i < numButtons; i++) {
			gamepad.buttons[i].nearlyTouched = args[o++];
		}
		for (i = 0; i < numButtons; i++) {
			gamepad.buttons[i].touched = args[o++];
		}
		for (i = 0; i < numButtons; i++) {
			gamepad.buttons[i].pressed = args[o++];
		}
		for (i = 0; i < numButtons; i++) {
			gamepad.buttons[i].value = args[o++];
		}

		if (gamepad.mapping === 'steamvr' || gamepad.mapping === 'touch') {
			gamepad.hand = args[o++];

			// Set position and rotation for existing apps
			gamepad.position.x = args[o++];
			gamepad.position.y = args[o++];
			gamepad.position.z = args[o++];

			gamepad.rotation.x = args[o++];
			gamepad.rotation.y = args[o++];
			gamepad.rotation.z = args[o++];
			gamepad.rotation.w = args[o++];

			// This is the proper WebVR Gamepad spec
			if (internal.enclosure.pixelsPerMeter) {
				gamepad.pose.position[0] = gamepad.position.x / internal.enclosure.pixelsPerMeter;
				gamepad.pose.position[1] = gamepad.position.y / internal.enclosure.pixelsPerMeter;
				gamepad.pose.position[2] = gamepad.position.z / internal.enclosure.pixelsPerMeter;
			} else {
				gamepad.pose.position[0] = gamepad.position.x;
				gamepad.pose.position[1] = gamepad.position.y;
				gamepad.pose.position[2] = gamepad.position.z;
			}

			// Rotate pose by 180 degrees on the y axis for WebVR
			if (!poseQuaternion) {
				poseQuaternion = new THREE.Quaternion();
			}
			poseQuaternion.copy(gamepad.rotation);
			poseQuaternion.multiply(new THREE.Quaternion(0, 1, 0, 0));
			gamepad.pose.orientation[0] = poseQuaternion.x;
			gamepad.pose.orientation[1] = poseQuaternion.y;
			gamepad.pose.orientation[2] = poseQuaternion.z;
			gamepad.pose.orientation[3] = poseQuaternion.w;
		}
	});
}());

/* global THREE */
(function () {
	var internal = window.altspace._internal;
	var document;
	var Document;
	altspace.getDocument = function () {
		var promise = engine.createDeferred();

		if (!document) {
			defineClasses();
			altspace.getEnclosure().then(function (enclosure) {
				document = new Document(enclosure);
				if (internal.getThreeJSScene()) {
					document.reset();
				}
				promise.resolve(document);
			});
		} else {
			setTimeout(function () {
				promise.resolve(document);
			}, 0);
		}

		return promise;
	};


	function defineClasses() {
		Document = function (enclosure) {
			var geometry = new THREE.PlaneGeometry(-enclosure.innerWidth / 1000, enclosure.innerHeight / 1000, 1, 1);
			this.originalGeometry = geometry;
			var texture = new THREE.Texture();
			texture.image = window.document.createElement('canvas');
			var material = new THREE.MeshBasicMaterial({
				side: THREE.DoubleSide,
				map: new THREE.Texture()
			});

			THREE.Mesh.call(this, geometry, material);

			this.type = 'Document';
			material.uuid = 'altspace-document';
			material.visible = false;

			var _inputEnabled = false;
			Object.defineProperty(this, 'inputEnabled', {
				set: function (value) {
					if (value === _inputEnabled) return;

					_inputEnabled = value;

					if (value) {
						internal.callClientFunction('EnableDOMInput');
					} else {
						internal.callClientFunction('DisableDOMInput');
					}
				},
				get: function () {
					return _inputEnabled;
				},
				enumerable: true,
				configurable: false
			});

			var _audioSpatializationEnabled = true;
			Object.defineProperty(this, 'audioSpatializationEnabled', {
				set: function (value) {
					if (value === _audioSpatializationEnabled) { return; }
					_audioSpatializationEnabled = value;
					if (value) {
						internal.callClientFunction('EnableAudioSpatialization');
					} else {
						internal.callClientFunction('DisbleAudioSpatialization');
					}
				},
				get: function () {
					return _audioSpatializationEnabled;
				},
				enumerable: true,
				configurable: false
			});
		};
		Document.prototype = Object.create(THREE.Mesh.prototype);
		Document.prototype.constructor = Document;
		Document.prototype.reset = function () {
			var currentScene = internal.getThreeJSScene();
			if (!currentScene) {
				console.warn('Document cannot be reset before render has been called');
				return;
			}
			currentScene.add(this);
			this.geometry = this.originalGeometry;
			this.geometry.verticesNeedUpdate = true;
			this.material.map.repeat.set(1, 1);
			this.material.side = THREE.DoubleSide;
			this.matrix.identity();
			this.matrix.getInverse(currentScene.matrix);
			this.applyMatrix(this.matrix);
		};
	}
}());

/* global THREE */
(function () {
	var internal = altspace._internal;
	var TrackingSkeleton;
	var TrackingJoint;

	var trackingSkeleton;
	var skeletonPromise;
	var resolvePromise;

	var firstUpdate = true;
	function init(trackingSkeletonFrame) {
		firstUpdate = false;
		trackingSkeleton = new TrackingSkeleton(trackingSkeletonFrame);
		resolvePromise(trackingSkeleton);
	}

	internal.onClientEvent('UpdateTrackingSkeleton', function () {
		var args = Array.prototype.slice.call(arguments);

		internal.forwardEventToChildIFrames('UpdateTrackingSkeleton', args);
		// Don't automatically create or update a skeleton if we are just passing the event to a lower iframe
		if (!skeletonPromise) return;

		var trackingSkeletonFrame = args;
		if (firstUpdate) {
			init(trackingSkeletonFrame);
			return;
		}
		trackingSkeleton.updateFromFrame(trackingSkeletonFrame);
	});

	function defineClasses() {
		TrackingJoint = function (skeletonFrame, offset) {
			THREE.Object3D.call(this);

			this.type = 'TrackingJoint';

			this.confidence = skeletonFrame[offset + 1];// TODO: nice string

			this.name = this.location = skeletonFrame[offset];// TODO: three part break;
		};
		TrackingJoint.prototype = Object.create(THREE.Object3D.prototype);
		TrackingJoint.prototype.constructor = TrackingJoint;
		TrackingJoint.prototype.updateFromFrame = function (skeletonFrame, offset) {
			this.confidence = skeletonFrame[offset + 1];
			this.position.set(
				skeletonFrame[offset + 2], skeletonFrame[offset + 3], skeletonFrame[offset + 4]);
			var quaternion = new THREE.Quaternion(
				skeletonFrame[offset + 5], skeletonFrame[offset + 6],
				skeletonFrame[offset + 7], skeletonFrame[offset + 8]);
			this.rotation.setFromQuaternion(quaternion);
		};


		TrackingSkeleton = function (initialFrame) {
			THREE.Object3D.call(this);

			this.type = 'TrackingSkeleton';

			this.trackingJoints = {};
			this.updateFromFrame(initialFrame);
		};
		TrackingSkeleton.prototype = Object.create(THREE.Object3D.prototype);
		TrackingSkeleton.prototype.constructor = TrackingSkeleton;
		TrackingSkeleton.prototype.updateFromFrame = function (skeletonFrame) {
			// Reset all joints to a confidence of 0 since the client doesn't send frames for
			// joints that are no longer tracked
			for (var jointLocation in this.trackingJoints) {
				if (this.trackingJoints.hasOwnProperty(jointLocation)) {
					this.trackingJoints[jointLocation].confidence = 0;
				}
			}

			// Frame is array of location, confidence, p.x, p.y, p.z, r.x, r.y, r.z, r.w
			for (var offset = 0, max = skeletonFrame.length; offset < max; offset += 9) {
				var frameJoint = skeletonFrame[offset];
				var trackingJoint = this.trackingJoints[frameJoint];

				if (!trackingJoint) {
					trackingJoint = this.trackingJoints[frameJoint] =
						new TrackingJoint(skeletonFrame, offset);
					this.add(trackingJoint);
				}

				trackingJoint.updateFromFrame(skeletonFrame, offset);
			}
		};
		TrackingSkeleton.prototype.getJoint = function (bodyPart, side, subIndex) {
			side = side || 'Center';
			subIndex = subIndex === undefined ? 0 : subIndex;
			// They are stored and accessed in pascal case, but this seems fine given the analogy
			// to TypeScript enums.
			return this.trackingJoints[side + bodyPart + subIndex];// Might be a faster way to do this.
		};
	}

	altspace.getThreeJSTrackingSkeleton = function () {
		if (skeletonPromise && !trackingSkeleton) { return skeletonPromise; }

		skeletonPromise = new Promise(function (resolve) {
			if (trackingSkeleton) {
				resolve(trackingSkeleton);
				return;
			}

			resolvePromise = resolve;
			defineClasses();
			internal.callClientFunction('GetTrackingSkeleton');
		});
		return skeletonPromise;
	};
}());

/* global THREE */
(function () {
	var tempInverseMatrix;
	var pooledWorldPosition;
	var pooledWorldQuaternion;
	var colliderExclusions = {};
	altspace._internal.onClientEvent('NativeTransformUpdateEvent', function (
		meshId,
		positionX,
		positionY,
		positionZ,
		rotationX,
		rotationY,
		rotationZ,
		rotationW) {

		tempInverseMatrix = tempInverseMatrix || new THREE.Matrix4();
		pooledWorldPosition = pooledWorldPosition || new THREE.Vector3();
		pooledWorldQuaternion = pooledWorldQuaternion || new THREE.Quaternion();

		var mesh = altspace._internal.getObject3DById(meshId);

		tempInverseMatrix.getInverse(altspace._internal.getThreeJSScene().matrix);

		pooledWorldPosition.set(positionX, positionY, positionZ);
		pooledWorldPosition.applyMatrix4(tempInverseMatrix);

		pooledWorldQuaternion.set(rotationX, rotationY, rotationZ, rotationW);
		//TODO: This function doesn't exist. Not taking scene rotation into account at the moment because of this.
		//Possibly compose the position and rotation into a single Matrix4 and apply the inverse scene matrix and then decompose the matrix.
		//pooledWorldQuaternion.applyMatrix4(tempInverseMatrix);

		var event = {
			type: 'native-transform-update',
			target: mesh,
			worldPosition: pooledWorldPosition,
			worldQuaternion: pooledWorldQuaternion
		}

		altspace._internal.dispatchObject3DEvent.call(mesh, event);

	});

	altspace.addNativeComponent = function (mesh, componentType) {

		switch (componentType) {
			case 'n-box-collider':
			case 'n-sphere-collider':
			case 'n-capsule-collider':
			case 'n-mesh-collider':
				if (!colliderExclusions[mesh.id]) {
					colliderExclusions[mesh.id] = componentType;
				}
				else {
					console.error('AltspaceVR: Mesh', mesh.id, 'already has a native collider, ignoring duplicate request.');
					return;
				}
		}

		altspace._internal.callClientFunction('AddNativeComponent', {
			MeshId: mesh.id,
			Type: componentType
		}, { argsType: 'JSTypeAddNativeComponent' });
	}

	altspace.removeNativeComponent = function (mesh, componentType) {
		altspace._internal.callClientFunction('RemoveNativeComponent', {
			MeshId: mesh.id,
			Type: componentType
		}, { argsType: 'JSTypeRemoveNativeComponent' });
	}

	altspace.updateNativeComponent = function (mesh, componentType, data) {
		if (data instanceof Object) {
			data = JSON.stringify(data);
		} else {
			data = JSON.stringify({ singularProperty: data });
		}

		altspace._internal.callClientFunction('UpdateNativeComponent', {
			MeshId: mesh.id,
			ComponentName: componentType,
			Attributes: data
		}, { argsType: 'JSTypeUpdateNativeComponent' });
	}

	altspace.callNativeComponentAction = function (mesh, componentType, functionName, functionArguments) {
		altspace._internal.callClientFunction('CallNativeComponentAction', {
			MeshId: mesh.id,
			ComponentName: componentType,
			FunctionName: functionName,
			Arguments: JSON.stringify(functionArguments)
		}, { argsType: 'JSTypeCallNativeComponent' });
	}

	altspace.callNativeComponentFunc = function (mesh, componentType, functionName, functionArguments) {
		return altspace._internal.callClientFunction('CallNativeComponentFunc', {
			MeshId: mesh.id,
			ComponentName: componentType,
			FunctionName: functionName,
			Arguments: JSON.stringify(functionArguments)
		}, { argsType: 'JSTypeCallNativeComponent' })
			.then(function (jsonStr) {
				return JSON.parse(jsonStr);
			});
	}

	altspace._internal.onClientEvent('NativeSoundLoadedEvent', function (meshId) {
		altspace._internal.forwardEventToChildIFrames('NativeSoundLoadedEvent', arguments);

		var object3D = altspace._internal.getObject3DById(meshId);
		var targetEl = object3D.el;

		if (targetEl) {
			targetEl.emit('n-sound-loaded', null, true);
		}
	});

	altspace._internal.onClientEvent('NativeGLTFLoadedEvent', function (meshId) {
		altspace._internal.forwardEventToChildIFrames('NativeGLTFLoadedEvent', arguments);

		var object3D = altspace._internal.getObject3DById(meshId);
		var targetEl = object3D.el;

		if (targetEl) {
			targetEl.emit('n-gltf-loaded', null, true);
		}
	});

})();


altspace.open = function (url, target, opts) {
	opts = opts || {};

	return altspace._internal.callClientFunction('OpenPopup', {
		Target: target || '_blank',
		Url: url,
		Hidden: !!opts.hidden,
		Icon: opts.icon,
	}, { argsType: 'OpenPopupOptions' }).then(function (winId) {
		var closed = false;
		return {
			show: function () {
				if (closed) { return undefined; }
				return altspace._internal.callClientFunction(
					'ShowPopup', { Id: winId }, { argsType: 'PopupIdOptions' });
			},
			close: function () {
				if (closed) { return undefined; }

				closed = true;
				return altspace._internal.callClientFunction(
					'ClosePopup', { Id: winId }, { argsType: 'PopupIdOptions' });
			}
		};
	});
};

(function () {
	var internal = altspace._internal;

	internal.onClientEvent('NativeCollisionEvent', function (
				type,
				thisMeshId,
				otherMeshId,
				relativeVelocityX,
				relativeVelocityY,
				relativeVelocityZ,
				normalX,
				normalY,
				normalZ,
				pointX,
				pointY,
				pointZ
			) {

		internal.forwardEventToChildIFrames('NativeCollisionEvent', arguments);//todo: do i need to do more here?

		var thisObject3D = internal.getObject3DById(thisMeshId);
		var otherObject3D = internal.getObject3DById(otherMeshId);

		var event = {
			type: type,
			bubbles: true,
			target: thisObject3D,
			other: otherObject3D,
			relativeVelocity: {
				x: relativeVelocityX,
				y: relativeVelocityY,
				z: relativeVelocityZ
			}
		}
		//TODO BUG: the position needs to be transformed by the scene
		//Some collision events (such as exit) seem to sometimes have no contact points
		if (normalX) {
			event.point = {
				position: {
					x: pointX,
					y: pointY,
					z: pointZ
				},
				normal: {
					x: normalX,
					y: normalY,
					z: normalZ
				}
			}
		}
		internal.dispatchObject3DEvent.call(thisObject3D, event);
	});
	internal.onClientEvent('NativeTriggerEvent', function (
				type,
				thisMeshId,
				otherMeshId
			) {

		internal.forwardEventToChildIFrames('NativeTriggerEvent', arguments);

		var thisObject3D = internal.getObject3DById(thisMeshId);
		var otherObject3D = internal.getObject3DById(otherMeshId);

		var event = {
			type: type,
			bubbles: true,
			target: thisObject3D,
			other: otherObject3D
		}
		internal.dispatchObject3DEvent.call(thisObject3D, event);
	});

	internal.onClientEvent('NativeContainerCountChanged', function (meshId, count, oldCount) {
		internal.forwardEventToChildIFrames('NativeContainerCountChanged', arguments);

		var object3D = internal.getObject3DById(meshId);
		var targetEl = object3D.el;

		if (targetEl) {
			targetEl.emit('container-count-changed', {
				count: count,
				oldCount: oldCount
			}, true);
		}
	});

	internal.onClientEvent('NativeContainerStateChanged', function (meshId, stateName, didGain) {
		internal.forwardEventToChildIFrames('NativeContainerStateChanged', arguments);

		var object3D = internal.getObject3DById(meshId);
		var targetEl = object3D.el;

		if (targetEl) {
			if (didGain) {
				targetEl.addState(stateName);
			} else {
				targetEl.removeState(stateName);
			}
		}
	});
}());

// Warning, this is only a shallow freeze. You should freeze any other functions or properties that should not be
// messed with.
Object.freeze(window.altspace);

altspace._internal.AltThriftHelper = (function () {
	var thriftString = Thrift.Type.STRING;
	var thriftInt = Thrift.Type.I32;
	var thriftMap = Thrift.Type.MAP;
	var thriftList = Thrift.Type.LIST;
	var thriftSet = Thrift.Type.SET;
	var thriftStruct = Thrift.Type.STRUCT;
	var thriftBool = Thrift.Type.BOOL;
	var thriftDouble = Thrift.Type.DOUBLE;

	var constr = function (buf) {
		this.buf = buf;
		this.pos = 0;
	}

	constr.prototype.writeFieldHeader = function (type, fieldId) {
		this.buf.setInt8(this.pos, type);
		this.buf.setInt16(this.pos + 1, fieldId);
		this.pos += 1 + 2;
	};

	constr.prototype.writeIntField = function(val, fieldId) {
		this.writeFieldHeader(thriftInt, fieldId);
		this.buf.setInt32(this.pos, val);
		this.pos += 4;
	};

	constr.prototype.writeStructFieldHeader = function(fieldId) {
		this.writeFieldHeader(thriftStruct, fieldId);
	};

	constr.prototype.writeInt = function(val) {
		this.buf.setInt32(this.pos, val);
		this.pos += 4;
	};

	constr.prototype.writeDoubleField = function(val, fieldId) {
		if (isNaN(val)) { throw new Error('Value cannot be NaN.'); }
		this.writeFieldHeader(thriftDouble, fieldId);
		this.buf.setFloat64(this.pos, val);
		this.pos += 8;
	};

	constr.prototype.writeBoolField = function(val, fieldId) {
		this.writeFieldHeader(thriftBool, fieldId);
		this.buf.setInt8(this.pos, val ? 1 : 0);
		this.pos += 1;
	};

	constr.prototype.writeStringBufferField = function (strBuffer, len, fieldId) {
		this.writeFieldHeader(thriftString, fieldId);
		this.buf.setInt32(this.pos, len);
		this.buf.setBuffer(this.pos + 4, strBuffer);
		this.pos += 4 + len;
	};

	constr.prototype.writeStringField = function(val, fieldId) {
		this.writeFieldHeader(thriftString, fieldId);
		this.writeString(val);
	};

	constr.prototype.writeString = function(val) {
		var len = this.buf.setUtf8String(this.pos + 4, val);
		this.buf.setInt32(this.pos, len);
		this.pos += 4 + len;
	};

	constr.prototype.writeStop = function() {
		this.buf.setInt8(this.pos, Thrift.Type.STOP);
		this.pos += 1;
	};

	constr.prototype.writeMapFieldAndGetCountPos = function(keyType, valueType, fieldId) {
		this.writeFieldHeader(thriftMap, fieldId);
		this.buf.setInt8(this.pos, keyType);
		this.buf.setInt8(this.pos + 1, valueType);

		var countPos = this.pos + 2;
		this.pos += 1 + 1 + 4;

		return countPos;
	};

	constr.prototype.writeListFieldAndGetCountPos = function(valueType, fieldId) {
		this.writeFieldHeader(thriftList, fieldId);
		this.buf.setInt8(this.pos, valueType);

		var countPos = this.pos + 1;
		this.pos += 1 + 4;

		return countPos;
	};

	constr.prototype.writeObjectCount = function(countPos, objCount) {
		this.buf.setInt32(countPos, objCount);
	};

	constr.prototype.writeObjectCountAndStop = function(countPos, objCount) {
		this.writeObjectCount(countPos, objCount);
		this.writeStop();
	};

	constr.prototype.getArray = function() {
		return this.buf.getArray().subarray(0, this.pos)
	}

	constr.prototype.getBinaryString = function () {
		var arr = this.getArray();
		return altspace._internal.DynamicThriftBuffer.toBinaryString(arr, arr.length);
	};

	return constr;
}());

/*
 * AltSceneUpdateSerializer serializes scene object updates into a Thrift message.
 *
 * Copyright (c) 2015 AltspaceVR
 */

altspace._internal.AltSceneUpdateSerializer = function (filter) {
	var buf = new Thrift.Buffer(1024 * 1024); // Allocate a meg of RAM for updates
	var bindingName = new Thrift.Buffer(255);
	var bindingNameLen = bindingName.setUtf8String(0, "UpdateThreeJSScene");
	var thriftHelper = new altspace._internal.AltThriftHelper(buf);
	var lastSceneObjectIds;
	var lastSceneTransforms = {};
	var lastSceneVisibilities = {};
	var serializeCount = 0;

	var worldPosition = new THREE.Vector3();
	var worldRotation = new THREE.Quaternion();
	var worldScale = new THREE.Vector3();

	var walk = function(obj, f) {
		if (filter(obj)) {
			f(obj);
		}

		var children = obj.children;
		
		for(var i = 0, max = children.length; i < max; i++) {
			walk(children[i], f);
		}
	};

	var matrixEquals = function(x, y) {
		// This is now in THREE.js on Matrix4, but is relatively
		// recent addition
		var xElements = x.elements;
		var yElements = y.elements;

		for (var i = 0; i < 16; i++) {
			if (xElements[i] !== yElements[i]) return false;
		}

		return true;
	};

	this.serializeScene = function (scene) {
		var updateCount = 0;
		var newSceneObjectIds = {};
		var removeCountPos = -1;
		var removeCount = 0;

		thriftHelper.pos = 0;

		thriftHelper.writeStringBufferField(bindingName, bindingNameLen, 1); // BindingName

		thriftHelper.writeIntField(0, 2); // RequestID

		thriftHelper.writeStructFieldHeader(3); // ThreeJSUpdate

		var updateCountPos = thriftHelper.writeListFieldAndGetCountPos(Thrift.Type.STRUCT, 1); // SceneObjectUpdates

		walk(scene, function(object3d) {
			var meshId = object3d.id;

			var isDirtyTransform = true;
			var isDirtyVisibility = true;

			var lastTransform = lastSceneTransforms[meshId];
			var newTransform = object3d.matrixWorld;

			var hasLastVisibility = lastSceneVisibilities.hasOwnProperty(meshId);
			var newVisibility = object3d.visible;

			if (lastTransform) {
				isDirtyTransform = !matrixEquals(lastTransform, newTransform);
			}

			if (isDirtyTransform || !lastTransform) {
				lastSceneTransforms[meshId] = newTransform.clone();
			}

			if (hasLastVisibility) {
				isDirtyVisibility = lastSceneVisibilities[meshId] != newVisibility;
			}

			if (isDirtyVisibility || !hasLastVisibility) {
				lastSceneVisibilities[meshId] = newVisibility;
			}

			newSceneObjectIds[meshId] = true;

			if (!isDirtyTransform && !isDirtyVisibility) return;

			object3d.matrixWorld.decompose( worldPosition, worldRotation, worldScale );

			try {
				thriftHelper.writeIntField(meshId, 1);
				thriftHelper.writeDoubleField(worldPosition.x, 2);
				thriftHelper.writeDoubleField(worldPosition.y, 3);
				thriftHelper.writeDoubleField(worldPosition.z, 4);
				thriftHelper.writeDoubleField(worldRotation.x, 5);
				thriftHelper.writeDoubleField(worldRotation.y, 6);
				thriftHelper.writeDoubleField(worldRotation.z, 7);
				thriftHelper.writeDoubleField(worldRotation.w, 8);
				thriftHelper.writeDoubleField(worldScale.x, 9);
				thriftHelper.writeDoubleField(worldScale.y, 10);
				thriftHelper.writeDoubleField(worldScale.z, 11);
				thriftHelper.writeBoolField(newVisibility, 12);
				thriftHelper.writeStop();
			}
			catch (e) {
				throw new Error('AltspaceVR: Could not serialize update for Mesh ' + object3d.uuid + '. ' + e.message);
			}
			updateCount++;
		});

		thriftHelper.writeObjectCount(updateCountPos, updateCount);

		if (lastSceneObjectIds) {
			for (var objId in lastSceneObjectIds) {
				if (lastSceneObjectIds.hasOwnProperty(objId)) {
					if (!newSceneObjectIds[objId]) {
						if (removeCount === 0) {
							// SceneObjectsToRemove
							removeCountPos = thriftHelper.writeListFieldAndGetCountPos(Thrift.Type.I32, 2);
						}

						thriftHelper.writeInt(objId);
						removeCount++;

						delete lastSceneTransforms[objId];
					}
				}
			}
		}

		if (removeCount > 0) {
			thriftHelper.writeObjectCount(removeCountPos, removeCount);
		}

		thriftHelper.writeIntField(serializeCount, 3); // Index, ordering updates

		thriftHelper.writeStop(); // /ThreeJsUpdate
		thriftHelper.writeStop(); // /BindCallMessage

		lastSceneObjectIds = newSceneObjectIds;

		serializeCount++;

		// Need to convert to a string type on the way out unfortunately :(
		// The WebView layer runs slow if you pass byte[] directly.
		return thriftHelper.getBinaryString();
	};
};

(function(exports){
'use strict';

	var prevTexStates = {};

	/**
	* Whether the texture should send update
	* @param {THREE.Texture} texture
	* @returns {boolean}
	*/
	exports.needsUpdate = function(texture)
	{
		if(!texture) return false;

		var prevTex = prevTexStates[texture.uuid];

		return !prevTex ||
			texture.needsUpdate ||
			texture.version !== prevTex.version ||
			texture.image && texture.image.src !== prevTex.src ||
			texture.offset.x !== prevTex.offsetX ||
			texture.offset.y !== prevTex.offsetY ||
			texture.repeat.x !== prevTex.repeatX ||
			texture.repeat.y !== prevTex.repeatY ||
			// Note: We only use wrapS because Unity does not support wrap modes on each axis.
			texture.wrapS !== prevTex.wrapS;
	}

	function updatePreviousTexState(texture, sourceHash)
	{
		if(!prevTexStates[texture.uuid])
			prevTexStates[texture.uuid] = {};

		var prevState = prevTexStates[texture.uuid];
		prevState.src = texture.image && texture.image.src || '';
		prevState.version = texture.version;
		prevState.offsetX = texture.offset.x;
		prevState.offsetY = texture.offset.y;
		prevState.repeatX = texture.repeat.x;
		prevState.repeatY = texture.repeat.y;
		prevState.wrapS = texture.wrapS;
		prevState.sourceHash = sourceHash;
	}

	function hashString(str)
	{
		var hash = 5381;
		var i = str.length - 1;
		var step = Math.max(Math.floor(i / 1024), 1); // Hack, take 1024 sampled bytes from really large data for perf.

		while (i >= 0) {
			hash = (hash * 33) ^ str.charCodeAt(i);
			i -= step;
		}

		return hash >>> 0;
	}

	function getDataUri(image)
	{
		var canvas;
		if (image.nodeName === 'CANVAS') {
			canvas = image;
		}
		else {
			canvas = document.createElement('canvas');
			canvas.width = image.width;
			canvas.height = image.height;
			var context = canvas.getContext('2d');
			context.drawImage(image, 0, 0, image.width, image.height);
		}
		return canvas.toDataURL('image/png');
	}

	/**
	* Get all textures in the scene,
	* loop over them,
	* and copy key fields from three object to thrift struct
	* @param {THREE.Scene} scene
	* @param {ThreeJSScene} thriftScene
	*/
	exports.serializeTextures = function(scene, thriftScene)
	{
		if(!thriftScene.Textures) return;
		var textures = {};
		getTextures(scene, textures);

		thriftScene.Textures.forEach(function(outTex)
		{
			var inTex = textures[outTex.Uuid];

			outTex.FlipY = inTex.flipY;
			outTex.OffsetX = inTex.offset.x;
			outTex.OffsetY = inTex.offset.y;
			outTex.RepeatX = inTex.repeat.x;
			outTex.RepeatY = inTex.repeat.y;
			// Note: We only use wrapS because Unity does not support wrap modes on each axis.
			outTex.WrapS = inTex.wrapS || THREE.ClampToEdgeWrapping;

			var prevState = prevTexStates[inTex.uuid];
			var prevSrc = prevState && prevState.src;
			var prevVersion = prevState && prevState.version;
			var prevSourceHash = prevState && prevState.sourceHash;

			// normal texture needs update
			if (inTex.image && inTex.image.src && prevSrc !== inTex.image.src)
			{
				outTex.Src = inTex.image.src;
				outTex.SourceHash = hashString(outTex.Src);
				outTex.TextureDataUri = '';
			}

			// canvas texture needs update
			else if( inTex.image &&
				(inTex.image.nodeName === 'CANVAS' || inTex.image.nodeName === 'VIDEO') &&
				(inTex.needsUpdate || inTex.version !== prevVersion)
			)
			{
				var dataUri = getDataUri(inTex.image);
				var textureData = new Thrift.Buffer(dataUri.length);
				textureData.setRawString(0, dataUri);
				outTex.TextureDataUri = textureData;
				outTex.SourceHash = hashString(dataUri);
				outTex.Src = '';
			}

			// texture parameter update only
			else if (prevSourceHash)
			{
				outTex.SourceHash = prevSourceHash;
				outTex.TextureDataUri = '';
				outTex.Src = '';
			}

			// should never happen
			else {
				outTex.SourceHash = 0;
				outTex.TextureDataUri = '';
				outTex.Src = '';
			}

			updatePreviousTexState(inTex, outTex.SourceHash);
			inTex.needsUpdate = false;
		});
	}

	/**
	* Create new thrift struct with given uuid
	* @param {string} texUuid
	* @returns {ThreeJSTexture}
	*/
	exports.getThriftTexture = function(tex)
	{
		var thriftTex = new ThreeJSTexture();
		thriftTex.Uuid = tex.uuid;
		return thriftTex;
	}

	/**
	* Recursively extract textures from tree, add to UUID-indexed map
	* @param {THREE.Object3D} obj
	* @param {Map[uuid: THREE.Texture]} texs - Output only
	*/
	function getTextures(obj, texs)
	{
		var mat = obj.material;
		if(mat && (mat.type === 'MultiMaterial' || mat.isMultiMaterial)){
			mat = mat.materials[0];
		}

		var map = mat && mat.map;
		if(map && !texs[map.uuid])
			texs[map.uuid] = map;

		var lightMap = mat && mat.lightMap;
		if(lightMap && !texs[lightMap.uuid])
			texs[lightMap.uuid] = lightMap;

		obj.children.forEach(function(c){
			getTextures(c, texs);
		});
	}

})(altspace._internal.TextureSerializer = {});

/*
 * AltGeoMatSerializer serializes a Three.js scene into a Thrift message.
 *
 * Copyright (c) 2015 AltspaceVR
 */
altspace._internal.AltGeoMatSerializer = function (options) {
	var PROFILE = options.profile;
	var TextureSerializer = altspace._internal.TextureSerializer;

	var getGeometries = function (obj, geometries) {
		if (obj.geometry) {
			geometries[obj.geometry.uuid] = obj.geometry;
		}
		for (var i = 0, l = obj.children.length; i < l; i ++) {
			getGeometries(obj.children[i], geometries);
		}
	};
	var geoNeedsUpdate = function (geo) {
		return (
			geo.needsUpdate === undefined ||
			geo.verticesNeedUpdate ||
			geo.elementsNeedUpdate ||
			geo.uvsNeedUpdate ||
			geo.normalsNeedUpdate ||
			geo.tangentsNeedUpdate ||
			geo.colorsNeedUpdate ||
			geo.lineDistancesNeedUpdate ||
			geo.groupsNeedUpdate
		);
	};
	var resetGeoFlags = function (geo) {
		if (geo) {
			geo.needsUpdate = false;
			geo.verticesNeedUpdate = false;
			geo.elementsNeedUpdate = false;
			geo.uvsNeedUpdate = false;
			geo.normalsNeedUpdate = false;
			geo.tangentsNeedUpdate = false;
			geo.colorsNeedUpdate = false;
			geo.lineDistancesNeedUpdate = false;
			geo.groupsNeedUpdate = false;
		}
	};

	var getThriftGeometryData = function (geometry) {
		var thriftGeometryData = new ThreeJSGeometryData();
		var jsonData;
		if (geometry instanceof THREE.Geometry) {
			jsonData = THREE.Geometry.prototype.toJSON.call(geometry).data;
			thriftGeometryData.Vertices = jsonData.vertices;
			thriftGeometryData.Faces = jsonData.faces;
			thriftGeometryData.Colors = jsonData.colors || [];
			thriftGeometryData.Uvs = jsonData.uvs && jsonData.uvs[0] || [];
			thriftGeometryData.Uvs2 = jsonData.uvs && jsonData.uvs[1] || [];
			thriftGeometryData.IsBufferedGeometry = false;
		}
		else if (geometry instanceof THREE.BufferGeometry) {
			jsonData = THREE.BufferGeometry.prototype.toJSON.call(geometry).data;
			thriftGeometryData.Vertices = jsonData.attributes.position.array;
			thriftGeometryData.Faces = jsonData.index && jsonData.index.array || [];
			if (jsonData.attributes.color && jsonData.attributes.color.type !== 'Float32Array') {
				throw new Error('AltspaceVR: geometry color array must be a Float32Array. Geometry ' + geometry.uuid);
			}
			thriftGeometryData.Colors = jsonData.attributes.color && jsonData.attributes.color.array || [];
			thriftGeometryData.Uvs = jsonData.attributes.uv && jsonData.attributes.uv.array || [];
			thriftGeometryData.Uvs2 = jsonData.attributes.uv2 && jsonData.attributes.uv2.array || [];
			thriftGeometryData.IsBufferedGeometry = true;
		}
		else {
			throw new Error('AltspaceVR: Unrecognized geometry type for geometry ' + geometry.uuid);
		}
		return thriftGeometryData;
	};

	var serializeGeometries = function (scene, thriftScene) {
		if (!thriftScene.Geometries) { return; }
		var geometries = {};
		getGeometries(scene, geometries);
		for (var j = 0, l = thriftScene.Geometries.length; j < l; j++) {
			var geometry = geometries[thriftScene.Geometries[j].Uuid];
			resetGeoFlags(geometry);
			var origParams = geometry.parameters;
			// Temporarily delete geo params so that toJSON actually serializes
			// vertices.
			delete geometry.parameters;
			thriftScene.Geometries[j].Data = getThriftGeometryData(geometry);
			geometry.parameters = origParams;
		}
	};

	var matWarns = [];
	var warnCutoff = 25;
	var matWhitelist = ['MeshBasicMaterial', 'MeshPhongMaterial', 'MeshLambertMaterial', 'MeshStandardMaterial'];
	var errorMats = {};

	// Phong and lambert aren't really supported, but various loaders only output these
	// types, and we don't want to spam users who can't actually fix it easily.
	var getMaterials = function (obj, materials)
	{
		if (obj.material)
		{
			if(obj.material.isMultiMaterial)
				var thisMat = obj.material[0];
			else
				thisMat = obj.material;
		
			// THIS IS THE ONLY IMPORTANT PART
			materials[thisMat.uuid] = thisMat;

			if( matWhitelist.indexOf(thisMat.type) === -1 && matWarns.indexOf(obj.uuid) === -1){
				if(matWarns.length < warnCutoff){
					console.warn(
						'AltspaceVR: Mesh ' + obj.uuid + ' uses unsupported material type "' + thisMat.type +
						'". This material will be approximated.' +
						' (This message will not be shown again for this object until the app is reloaded)'
					);
					matWarns.push(obj.uuid);
					if(matWarns.length === warnCutoff){
						console.warn('AltspaceVR: Maximum material warning count reached.');
					}
				}
			}
		}
		if (!obj.children) { return; }
		for (var i = 0, l = obj.children.length; i < l; i ++) {
			getMaterials(obj.children[i], materials);
		}
	};

	var previousMatStates = {};
	var matNeedsUpdate = function (mat)
	{
		if(mat.isMultiMaterial){
			mat = mat[0];
		}

		if (!mat) { return false; }

		var prevMat = previousMatStates[mat.uuid];

		if(mat.type === 'MultiMaterial'){
			var multimat = mat;
			mat = multimat.materials[0];
		}

		if(/^(Raw)?ShaderMaterial$/.test(mat.type))
		{
			if(!errorMats[mat.uuid]){
				errorMats[mat.uuid] = new THREE.MeshBasicMaterial();
				errorMats[mat.uuid].uuid = mat.uuid;
			}

			if(mat.visible !== undefined)
				errorMats[mat.uuid].visible = mat.visible;
			if(mat.color !== undefined )
				errorMats[mat.uuid].color.copy(mat.color);
			if(mat.map !== undefined)
				errorMats[mat.uuid].map = mat.map;
			if(mat.lightMap !== undefined)
				errorMats[mat.uuid].lightMap = mat.lightMap;
			if(mat.lightMapIntensity !== undefined)
				errorMats[mat.uuid].lightMapIntensity = mat.lightMapIntensity;
			if(mat.transparent !== undefined)
				errorMats[mat.uuid].transparent = mat.transparent;
			if(mat.opacity !== undefined)
				errorMats[mat.uuid].opacity = mat.opacity;
			if(mat.side !== undefined)
				errorMats[mat.uuid].side = mat.side;

			mat = errorMats[mat.uuid];
		}

		return prevMat === undefined ||
			(multimat ? multimat.visible : mat.visible) !== prevMat.visible ||
			mat.side !== prevMat.side ||
			mat.transparent !== prevMat.transparent ||
			mat.opacity !== prevMat.opacity ||
			mat.color.getHex() !== prevMat.color ||
			mat.map && mat.map.uuid !== prevMat.map ||
			mat.lightMap && mat.lightMap.uuid !== prevMat.lightMap ||
			mat.lightMapIntensity !== prevMat.lightMapIntensity;
	};

	var updatePreviousMatStates = function (mat)
	{
		if(mat.isMultiMaterial){
			mat = mat[0];
		}
	
		var prevMat = previousMatStates[mat.uuid];
		if (prevMat === undefined) {
			prevMat = previousMatStates[mat.uuid] = {};
		}

		if(mat.type === 'MultiMaterial'){
			var multimat = mat;
			mat = multimat.materials[0];
		}
	
		if(/^(Raw)?ShaderMaterial$/.test(mat.type)){
			mat = errorMats[mat.uuid];
		}

		prevMat.visible = multimat ? multimat.visible : mat.visible;
		prevMat.side = mat.side;
		prevMat.transparent = mat.transparent;
		prevMat.opacity = mat.opacity;
		prevMat.color = mat.color && mat.color.getHex();
		prevMat.map = mat.map && mat.map.uuid || '';
		prevMat.lightMap = mat.lightMap && mat.lightMap.uuid || '';
		prevMat.lightMapIntensity = mat.lightMapIntensity;
	};

	var serializeMaterials = function (scene, thriftScene)
	{
		if (!thriftScene.Materials) { return; }
		var materials = {};
		getMaterials(scene, materials);

		for (var j = 0, l = thriftScene.Materials.length; j < l; j++)
		{
			var outMaterial = thriftScene.Materials[j];
			var material = materials[outMaterial.Uuid];

			if(material.isMultiMaterial){
				material = material[0] || {};
			}
			else if(material.type === 'MultiMaterial'){
				var multimat = material;
				material = multimat.materials[0] || {};
			}
			
			if(/^(Raw)?ShaderMaterial$/.test(material.type)){
				material = errorMats[material.uuid];
			}

			outMaterial.Visible = multimat ? multimat.visible : material.visible;
			outMaterial.Side = material.side;
			outMaterial.Transparent = material.transparent;
			outMaterial.Opacity = material.opacity;
			outMaterial.Color = material.color ? material.color.getHex() : -1;
			outMaterial.Map = material.map && material.map.uuid || '';
			outMaterial.LightMap = material.lightMap && material.lightMap.uuid || '';
			outMaterial.LightMapIntensity =
				material.lightMapIntensity !== undefined ? material.lightMapIntensity : 1;

			updatePreviousMatStates(material);
		}
	};

	var sceneMeshes = {};

	var getThriftGeometry = function (geoUuid) {
		var thriftGeometry = new ThreeJSGeometry();
		thriftGeometry.Uuid = geoUuid;
		return thriftGeometry;
	};

	var getThriftMaterial = function (material) {
		var thriftMaterial = new ThreeJSMaterial();
		// Note: Here we take the original material uuid even if it's a MultiMaterial.
		// When we actually go ahead and serialize the MultiMaterial, we take the definition from the first material.
		thriftMaterial.Uuid = material.isMultiMaterial ? material[0].uuid : material.uuid;
		return thriftMaterial;
	};

	var getVertexCount = function (geometry) {
		return (
			// THREE.Geometry
			geometry.faces && geometry.faces.length * 3 ||
			// BufferGeometry
			geometry.attributes && geometry.attributes.position && geometry.attributes.position.count
		);
	};

	var hasValidGeometry = function (obj) {
		if (!obj.geometry) { return false; }
		return getVertexCount(obj.geometry) > 0;
	};

	var previousAltspaceFlagStates = {};
	var altspaceFlagsNeedUpdate = function (obj) {
		var userData = obj.userData;
		if (!(userData && userData.altspace && userData.altspace.collider)) {
			return false;
		}
		var prevState = previousAltspaceFlagStates[obj.uuid];
		if (!prevState && userData.altspace.collider.enabled === false) {
			return true;
		}
		if (prevState && prevState.collider.enabled !== userData.altspace.collider.enabled) {
			return true;
		}
	};
	var updatePreviousAltspaceFlags = function (obj) {
		var userData = obj.userData;
		if (!(userData && userData.altspace && userData.altspace.collider)) { return; }
		if (!previousAltspaceFlagStates[obj.uuid]) {
			previousAltspaceFlagStates[obj.uuid] = {collider: {}};
		}
		previousAltspaceFlagStates[obj.uuid].collider.enabled = userData.altspace.collider.enabled;
	};

	// Unity cannot load meshes with more than 65000 vertices.
	var maxVertexCount = 65535;

	var getMeshesGeosMatsTexs = function (obj, meshes, geos, mats, texs)
	{
		if (obj instanceof THREE.Mesh && hasValidGeometry(obj)) {
			var vertexCount = getVertexCount(obj.geometry);
			if (vertexCount > maxVertexCount) {
				if (!sceneMeshes[obj.uuid]) {
					console.error(
						'AltspaceVR: Skipping mesh ' + obj.uuid +
						' since its vertex count (' + vertexCount.toLocaleString() + ') exceeds ' +
						maxVertexCount.toLocaleString() +
						' (This message will not be shown again for this object until the app is reloaded)'
					);
					sceneMeshes[obj.uuid] = true;
				}
				return;
			}
			var geoNeededUpdate, matNeededUpdate, texNeededUpdate, altspaceFlagsNeededUpdate;
			if (!geos[obj.geometry.uuid] && geoNeedsUpdate(obj.geometry)) {
				geos[obj.geometry.uuid] = getThriftGeometry(obj.geometry.uuid);
				geoNeededUpdate = true;
			}

			var mat = obj.material;

			// Note that we use the uuid of the MultiMaterial above but we serizlize the textures of the first material
			if(mat.isMultiMaterial){
				mat = mat[0] || {};
			}

			if (!mats[mat.uuid] && matNeedsUpdate(mat)) {
				mats[mat.uuid] = getThriftMaterial(mat);
				matNeededUpdate = true;
			}
			
			if(mat.map && !texs[mat.map.uuid] &&
				TextureSerializer.needsUpdate(mat.map))
			{
				texs[mat.map.uuid] = TextureSerializer.getThriftTexture(mat.map);
				texNeededUpdate = true;
			}
			
			if(mat.lightMap && !texs[mat.lightMap.uuid] &&
				TextureSerializer.needsUpdate(mat.lightMap))
			{
				texs[mat.lightMap.uuid] = TextureSerializer.getThriftTexture(mat.lightMap);
				texNeededUpdate = true;
			}

			if (altspaceFlagsNeedUpdate(obj)) {
				altspaceFlagsNeededUpdate = true;
			}
			if (
				geoNeededUpdate ||
				matNeededUpdate ||
				texNeededUpdate ||
				altspaceFlagsNeededUpdate ||
				!sceneMeshes[obj.uuid]
			) {
				var thriftMesh = new ThreeJSMesh();
				thriftMesh.Geometry = obj.geometry.uuid;
				thriftMesh.Material = mat.uuid;
				thriftMesh.MeshId = obj.id;

				thriftMesh.AltspaceFlags = new ThreeJSAltspaceFlags();
				thriftMesh.AltspaceFlags.ColliderFlags = new ThreeJSColliderFlags();
				thriftMesh.AltspaceFlags.ColliderFlags.Enabled = !!(
					// The collider should be enabled by default
					!(obj.userData && obj.userData.altspace && obj.userData.altspace.collider) ||
					obj.userData.altspace.collider.enabled === undefined ||
					obj.userData.altspace.collider.enabled
				);


				meshes.push(thriftMesh);
				sceneMeshes[obj.uuid] = true;
				updatePreviousAltspaceFlags(obj);
			}
		}
		if (!obj.children) { return; }
		for (var i = 0; i < obj.children.length; i++) {
			getMeshesGeosMatsTexs(obj.children[i], meshes, geos, mats, texs);
		}
	};
	var getValues = function (obj) {
		var values = [];
		for (var key in obj) {
			if (obj.hasOwnProperty(key)) {
				values.push(obj[key]);
			}
		}
		return values;
	};
	var getThriftScene = function (scene) {
		var thriftScene = new ThreeJSScene();
		var meshes = [];
		var geos = {};
		var mats = {};
		var texs = {};
		getMeshesGeosMatsTexs(scene, meshes, geos, mats, texs);
		thriftScene.Geometries = getValues(geos);
		thriftScene.Materials = getValues(mats);
		thriftScene.Textures = getValues(texs);
		thriftScene.Meshes = meshes;

		thriftScene.Initialized = false;
		if (scene.userData.altspace) {
			var initialized = scene.userData.altspace.initialized;
			thriftScene.Initialized = initialized;
			previousAltspaceFlagStates[scene.uuid] = previousAltspaceFlagStates[scene.uuid] || {};
			previousAltspaceFlagStates[scene.uuid].initialized = initialized;
		}

		return thriftScene;
	};
	var sceneUuidList = [];
	var lastMeshCount = 0;

	var serializeCount = 0;
	var totalSerializeLength = 0;
	var serializeLength = 0;
	var totalTime = 0;
	var needsUpdateTime = 0;
	var needsUpdateCount = 0;
	var serializeTime = 0;
	var lastLog = performance.now();
	var logPerformance = function () {
		var serializeLengthKB = serializeLength / 1024;
		console.info(
			'\nNeedsUpdate Count', needsUpdateCount,
			'\nAverage NeedsUpdate MS', (needsUpdateTime / needsUpdateCount).toFixed(3),
			'\nSerialize Count:', serializeCount,
			'\nAverage Serialize MS', (serializeTime / serializeCount).toFixed(3),
			'\nAverage Serialize KB', (serializeLengthKB / serializeCount).toFixed(3),
			'\nTotal MS', totalTime.toFixed(3),
			'\nTotal Serialized KB', (totalSerializeLength / 1024).toFixed(3)
		);
	};

	this.sceneNeedsUpdate = function (scene) {
		var start;
		if (PROFILE) {
			start = performance.now();
		}

		var needsUpdate = false;
		var objCounter = 0;
		var meshCounter = 0;
		scene.traverse(function (obj) {
			var sceneListChanged = sceneUuidList[objCounter] !== obj.uuid;
			var objHasValidGeometry = hasValidGeometry(obj);
			if (objHasValidGeometry) {
				meshCounter++;
				if (sceneMeshes[obj.uuid]) {
					// The scene still has the mesh, so flip it to false so that we can prune removed meshes below.
					sceneMeshes[obj.uuid] = false;
				}
			}
			if (
				sceneListChanged ||
				objHasValidGeometry &&
				(
					geoNeedsUpdate(obj.geometry) ||
					matNeedsUpdate(obj.material) ||
					TextureSerializer.needsUpdate(obj.material.map) ||
					TextureSerializer.needsUpdate(obj.material.lightMap) ||
					altspaceFlagsNeedUpdate(obj)
				)
			) {
				needsUpdate = true;
			}
			sceneUuidList[objCounter] = obj.uuid;
			objCounter++;
		});
		if (meshCounter > lastMeshCount) {
			needsUpdate = true;
		}
		Object.keys(sceneMeshes).forEach(function (key) {
			if (sceneMeshes[key] === false) {
				// This mesh was found in the traversal above. Flip it to indicate that it's still in the scene.
				sceneMeshes[key] = true;
			} else {
				// This mesh was not found in the traversal. It's been removed, so remove it from sceneMeshes as well.
				delete sceneMeshes[key];
			}
		});
		lastMeshCount = meshCounter;
		var prevFlagState = previousAltspaceFlagStates[scene.uuid];
		var sceneFlags = scene.userData.altspace;
		if (sceneFlags && (!prevFlagState || prevFlagState.initialized !== sceneFlags.initialized)) {
			needsUpdate = true;
		}

		if (PROFILE) {
			var delta = performance.now() - start;
			needsUpdateTime += delta;
			totalTime += delta;
			needsUpdateCount++;
			if (performance.now() - lastLog > 1000) {
				logPerformance();
				serializeCount = serializeLength = serializeTime = needsUpdateTime = needsUpdateCount = 0;
				lastLog = performance.now();
			}
		}

		return needsUpdate;
	};
	this.serializeScene = function (scene) {
		var start;
		if (PROFILE) {
			start = performance.now();
		}

		var thriftScene = getThriftScene(scene);
		serializeGeometries(scene, thriftScene);
		serializeMaterials(scene, thriftScene);
		TextureSerializer.serializeTextures(scene, thriftScene);

		var bindCallMessage = new BindCallMessage();
		bindCallMessage.BindingName = "RenderThreeJSScene";
		bindCallMessage.RequestID = 0;
		bindCallMessage.ThreeJSScene = thriftScene;

		var output = altspace._internal.ScratchThriftBuffer.getBinaryString(bindCallMessage);

		if (PROFILE) {
			var delta = performance.now() - start;
			serializeTime += delta;
			serializeCount++;
			serializeLength += output.length;
			totalSerializeLength += output.length;
			totalTime += delta;
		}
		return output;
	};
	this.hasValidGeometry = hasValidGeometry;
};

/*
 * AltRenderer renders a Three.js scene in the Altspace web browser.
 *
 * Author: Gavan Wilhite
 * Copyright (c) 2015 AltspaceVR
 */

var GEO_MAT_VERSION = '0.2.0';

altspace._internal.AltRenderer = function ( options ) {
	options = options || {};
	console.log( 'THREE.AltRenderer', THREE.REVISION );

	var serializationFilter;
	var geoMatSerializer;

	if (!options.version || options.version === GEO_MAT_VERSION) {
		options.version = GEO_MAT_VERSION;
		geoMatSerializer = new altspace._internal.AltGeoMatSerializer({profile: options.profile});
		serializationFilter = function (object3d) {
			return (
				object3d instanceof THREE.Mesh &&
				geoMatSerializer.hasValidGeometry(object3d)
			);
		};
	}
	else {
		// TODO Deprecate v0.1
		options.version = '0.1.0';
		serializationFilter = function (object3d) {
			// Objects loaded by AltOBJMTLLoader have a 'src' property.
			return object3d.userData.hasOwnProperty('src');
		};
	}
	console.log("AltRenderer version " + options.version);

	var sceneUpdateSerializer = new altspace._internal.AltSceneUpdateSerializer(serializationFilter);

	Object.defineProperty(this, "domElement", {
		get : function(){
			console.log("AltRenderer.domElement not implemented");
			return null;
		},
		configurable: true
	});

	function sendClientThriftMessage(func, message) {
		altspace._internal.callClientFunction(
			func,
			{ Message: message },
			{ argsType: "ThriftMessage" }
		);
	}

	function sendClientThriftAction(func, message) {
		altspace._internal.callClientAction(
			func,
			{ Message: message },
			{ argsType: "ThriftMessage" }
		);
	}

	function sendSceneToAltspace(serializedScene){
		sendClientThriftMessage("RenderThreeJSScene", serializedScene);
	}

	function sendUpdatesToAltspace(sceneUpdateMessage){
		sendClientThriftMessage("UpdateThreeJSScene", sceneUpdateMessage);
	}

	var initialRender = true;
	var exceptionCount = 0;
	this.render = function ( scene ) {
		altspace._internal.setThreeJSScene(scene);
		scene.updateMatrixWorld();
		if (options.version === GEO_MAT_VERSION)
		{
			try {
				if(geoMatSerializer.sceneNeedsUpdate(scene) || initialRender) {
					initialRender = false;
					var serializedScene = geoMatSerializer.serializeScene(scene);
					sendSceneToAltspace( serializedScene );
				}
			}
			catch(err){
				if(exceptionCount++ < 20){
					console.error('Error serializing scene:', err.stack);
				}
				else if(exceptionCount === 21){
					console.error('Maximum exception count reached. Suppressing errors.');
				}
				return;
			}
		}

		var sceneUpdateMessage = sceneUpdateSerializer.serializeScene(scene);
		sendUpdatesToAltspace(sceneUpdateMessage);
	};
};
